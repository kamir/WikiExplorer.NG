package com.cloudera.wikiexplorer.ng.app;

import static com.cloudera.wikipedia.explorer.ESProcessor2.noIdentifier;
import org.apache.hadoopts.chart.simple.MultiChart;
import org.apache.hadoopts.chart.simple.MultiChartDistComp;
import com.ibm.icu.util.Calendar;
import com.ibm.icu.util.GregorianCalendar;
import org.apache.hadoopts.data.export.OriginProject;
import org.apache.hadoopts.data.series.Messreihe;
import org.apache.hadoopts.data.export.MesswertTabelle;
import org.apache.hadoopts.hadoopts.core.SingleRowTSO;
import org.apache.hadoopts.hadoopts.core.TSBucket;
import org.apache.hadoopts.hadoopts.topics.wikipedia.LocalWikipediaNetwork2;
import java.awt.Color;
import java.awt.Container;
import java.awt.Toolkit;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JPanel;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.SequenceFile;
import org.apache.hadoop.io.Text;
import org.openide.util.Exceptions;
import research.ETH.ExtendedNodePair;
import research.ETH.ExtendedNodePairSFE; 
import statistics.HaeufigkeitsZaehlerDoubleSIMPLE;
import experiments.crosscorrelation.KreuzKorrelation;
import experiments.crosscorrelation.IntraCorrelationAnalysis;
import experiments.linkstrength.CheckInfluenceOfSingelPeaks;
import m3.tscache.TSCache; 
import m3.wikipedia.corpus.extractor.NetDensityCalc;
import m3.wikipedia.corpus.extractor.edits.WikiHistoryExtraction2;
import m3.wikipedia.explorer.data.WikiNode;
import org.apache.hadoopts.statistics.HaeufigkeitsZaehlerDouble;
import com.cloudera.wikipedia.explorer.AdvancedSequenceFileExplorer;
import com.cloudera.wikipedia.explorer.BucketLoaderTool; 
import com.cloudera.wikipedia.explorer.ChartComparisonFrame;
import com.cloudera.wikipedia.explorer.ChartFrame;
import com.cloudera.wikipedia.explorer.ESProcessor2;
import com.cloudera.wikipedia.explorer.GTSB2;
import com.cloudera.wikipedia.explorer.HadoopTSAdapter;
import com.cloudera.wikipedia.explorer.LocalNetFrame;
import com.cloudera.wikipedia.explorer.MetacorrelationAnalysisV2;
import com.cloudera.wikipedia.explorer.ResultManager;
import com.cloudera.wikipedia.explorer.StockDataLoader2;
import experiments.crosscorrelation.CCProzessor;

/**
 *
 * @author root
 */
public class SimpleSFE extends javax.swing.JFrame {

    final static boolean exportViaGephi = false;

    /**
     * Creates new form SequenceFileExplorer
     */
    public SimpleSFE() {
        initComponents();
        com.cloudera.wikiexplorer.ng.gui.GUITool.fullScreen(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        buttonGroup3 = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();
        jPanel3 = new javax.swing.JPanel();
        jtfEXTFILE = new javax.swing.JTextField();
        jbINSPECT = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jtLF = new javax.swing.JTextField();
        jlZ = new javax.swing.JLabel();
        jtfSTUDIE = new javax.swing.JTextField();
        jPanel6 = new javax.swing.JPanel();
        jtJAHR = new javax.swing.JTextField();
        jtMONAT = new javax.swing.JTextField();
        jtTAG = new javax.swing.JTextField();
        jtL = new javax.swing.JTextField();
        jRadioButton1 = new javax.swing.JRadioButton();
        jRadioButton2 = new javax.swing.JRadioButton();
        jRadioButton3 = new javax.swing.JRadioButton();
        jTextField1 = new javax.swing.JTextField();
        jTextField2 = new javax.swing.JTextField();
        jTextField3 = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jTextField4 = new javax.swing.JTextField();
        selectedK = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jButton11 = new javax.swing.JButton();
        jPanel7 = new javax.swing.JPanel();
        jcbRAW = new javax.swing.JCheckBox();
        jcbMW = new javax.swing.JCheckBox();
        jcbRATIO = new javax.swing.JCheckBox();
        jLabel5 = new javax.swing.JLabel();
        jtfFolderEXTRACT = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        label1 = new java.awt.Label();
        jButton2 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        jtfLIMIT = new javax.swing.JTextField();
        jPanel8 = new javax.swing.JPanel();
        jCheckBox1 = new javax.swing.JCheckBox();
        jcbWT = new javax.swing.JCheckBox();
        jcbDT = new javax.swing.JCheckBox();
        jPanel9 = new javax.swing.JPanel();
        jButton5 = new javax.swing.JButton();
        jcbONLYSELECTION = new javax.swing.JCheckBox();
        jButton3 = new javax.swing.JButton();
        jcbCC = new javax.swing.JCheckBox();
        jcbES = new javax.swing.JCheckBox();
        jButton6 = new javax.swing.JButton();
        jbAnalyseDATA = new javax.swing.JButton();
        jrbCCSelector = new javax.swing.JRadioButton();
        jrbIW = new javax.swing.JRadioButton();
        jComboBox1 = new javax.swing.JComboBox();
        jButton1 = new javax.swing.JButton();
        jButton12 = new javax.swing.JButton();
        jButton13 = new javax.swing.JButton();
        jRadioButton5 = new javax.swing.JRadioButton();
        jButton14 = new javax.swing.JButton();
        jcbLOadEditHistory = new javax.swing.JCheckBox();
        jButton7 = new javax.swing.JButton();
        jButton8 = new javax.swing.JButton();
        jButton9 = new javax.swing.JButton();
        jRadioButton4 = new javax.swing.JRadioButton();
        jPanel10 = new javax.swing.JPanel();
        jcbADJUST = new javax.swing.JCheckBox();
        jrbSimpShuffle = new javax.swing.JRadioButton();
        jRadioButton6 = new javax.swing.JRadioButton();
        jButton10 = new javax.swing.JButton();
        jButton15 = new javax.swing.JButton();
        jButton16 = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        jPanel4 = new javax.swing.JPanel();
        jPanel5 = new javax.swing.JPanel();
        menuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        openMenuItem = new javax.swing.JMenuItem();
        saveMenuItem = new javax.swing.JMenuItem();
        saveAsMenuItem = new javax.swing.JMenuItem();
        exitMenuItem = new javax.swing.JMenuItem();
        editMenu = new javax.swing.JMenu();
        cutMenuItem = new javax.swing.JMenuItem();
        copyMenuItem = new javax.swing.JMenuItem();
        pasteMenuItem = new javax.swing.JMenuItem();
        deleteMenuItem = new javax.swing.JMenuItem();
        helpMenu = new javax.swing.JMenu();
        contentsMenuItem = new javax.swing.JMenuItem();
        aboutMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("wikipedia/explorer/Bundle"); // NOI18N
        setTitle(bundle.getString("SimpleSFE.title")); // NOI18N

        jPanel2.setLayout(new java.awt.BorderLayout());

        jScrollPane2.setPreferredSize(new java.awt.Dimension(158, 130));

        jScrollPane2.setViewportView(jList1);

        jPanel2.add(jScrollPane2, java.awt.BorderLayout.CENTER);

        jPanel3.setBackground(java.awt.Color.white);
        jPanel3.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));
        jPanel3.setPreferredSize(new java.awt.Dimension(787, 360));

        jtfEXTFILE.setBackground(new java.awt.Color(237, 237, 235));
        java.util.ResourceBundle bundle1 = java.util.ResourceBundle.getBundle("app/Bundle"); // NOI18N
        jtfEXTFILE.setText(bundle1.getString("SimpleSFE.jtfEXTFILE.text")); // NOI18N
        jtfEXTFILE.setEnabled(false);

        jbINSPECT.setText(bundle1.getString("SimpleSFE.jbINSPECT.text")); // NOI18N
        jbINSPECT.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbINSPECTActionPerformed(evt);
            }
        });

        jLabel1.setText(bundle1.getString("SimpleSFE.jLabel1.text")); // NOI18N

        jtLF.setFont(new java.awt.Font("DejaVu Sans", 0, 10)); // NOI18N
        jtLF.setText(bundle1.getString("SimpleSFE.jtLF.text")); // NOI18N

        jlZ.setFont(new java.awt.Font("DejaVu Sans", 1, 13)); // NOI18N
        jlZ.setText(bundle1.getString("SimpleSFE.jlZ.text")); // NOI18N

        jtfSTUDIE.setText(bundle1.getString("SimpleSFE.jtfSTUDIE.text")); // NOI18N
        jtfSTUDIE.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfSTUDIEActionPerformed(evt);
            }
        });
        jtfSTUDIE.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jtfSTUDIEFocusLost(evt);
            }
        });

        jPanel6.setBackground(java.awt.Color.white);
        jPanel6.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jPanel6.border.title"))); // NOI18N

        jtJAHR.setText(bundle1.getString("SimpleSFE.jtJAHR.text")); // NOI18N
        jtJAHR.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jtJAHR.border.title"))); // NOI18N
        jtJAHR.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtJAHRActionPerformed(evt);
            }
        });

        jtMONAT.setText(bundle1.getString("SimpleSFE.jtMONAT.text")); // NOI18N
        jtMONAT.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jtMONAT.border.title"))); // NOI18N

        jtTAG.setText(bundle1.getString("SimpleSFE.jtTAG.text")); // NOI18N
        jtTAG.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jtTAG.border.title"))); // NOI18N

        jtL.setText(bundle1.getString("SimpleSFE.jtL.text")); // NOI18N
        jtL.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jtL.border.title"))); // NOI18N
        jtL.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtLKeyPressed(evt);
            }
        });

        buttonGroup1.add(jRadioButton1);
        jRadioButton1.setSelected(true);
        jRadioButton1.setText(bundle1.getString("SimpleSFE.jRadioButton1.text")); // NOI18N

        buttonGroup1.add(jRadioButton2);
        jRadioButton2.setText(bundle1.getString("SimpleSFE.jRadioButton2.text")); // NOI18N

        buttonGroup1.add(jRadioButton3);
        jRadioButton3.setText(bundle1.getString("SimpleSFE.jRadioButton3.text")); // NOI18N

        jTextField1.setText(bundle1.getString("SimpleSFE.jTextField1.text")); // NOI18N
        jTextField1.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jTextField1.border.title"))); // NOI18N

        jTextField2.setText(bundle1.getString("SimpleSFE.jTextField2.text")); // NOI18N
        jTextField2.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jTextField2.border.title"))); // NOI18N

        jTextField3.setText(bundle1.getString("SimpleSFE.jTextField3.text")); // NOI18N
        jTextField3.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jTextField3.border.title"))); // NOI18N

        jLabel8.setText(bundle1.getString("SimpleSFE.jLabel8.text")); // NOI18N

        jTextField4.setText(bundle1.getString("SimpleSFE.jTextField4.text")); // NOI18N
        jTextField4.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jTextField4.border.title"))); // NOI18N

        selectedK.setText(bundle1.getString("SimpleSFE.selectedK.text")); // NOI18N
        selectedK.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.selectedK.border.title"))); // NOI18N

        jLabel2.setText(bundle1.getString("SimpleSFE.jLabel2.text")); // NOI18N

        jButton11.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton11.text")); // NOI18N
        jButton11.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton11ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addComponent(jRadioButton3)
                .addGap(18, 18, 18)
                .addComponent(jtJAHR, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jtMONAT, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jtTAG, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jtL, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(selectedK, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel6Layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jButton11)
                                .addGap(24, 24, 24))))
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jRadioButton1)
                            .addComponent(jRadioButton2))
                        .addGap(18, 18, 18)
                        .addComponent(jLabel8)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 56, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(18, 18, 18))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jRadioButton3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jRadioButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jRadioButton2))
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jtJAHR, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jtMONAT, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jtTAG, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jtL, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel8)
                            .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 33, Short.MAX_VALUE)
                        .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(selectedK, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap())
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addGap(1, 1, 1)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton11)
                        .addContainerGap(32, Short.MAX_VALUE))))
        );

        jPanel7.setBackground(java.awt.Color.white);
        jPanel7.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jPanel7.border.title"))); // NOI18N

        jcbRAW.setSelected(true);
        jcbRAW.setText(bundle1.getString("SimpleSFE.jcbRAW.text")); // NOI18N

        jcbMW.setBackground(java.awt.Color.white);
        jcbMW.setSelected(true);
        jcbMW.setText(bundle1.getString("SimpleSFE.jcbMW.text")); // NOI18N

        jcbRATIO.setSelected(true);
        jcbRATIO.setText(bundle1.getString("SimpleSFE.jcbRATIO.text")); // NOI18N

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jcbMW, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jcbRATIO, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jcbRAW))
                .addContainerGap(9, Short.MAX_VALUE))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addComponent(jcbRAW)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jcbMW)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jcbRATIO)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jLabel5.setText(bundle1.getString("SimpleSFE.jLabel5.text")); // NOI18N

        jtfFolderEXTRACT.setText(bundle1.getString("SimpleSFE.jtfFolderEXTRACT.text")); // NOI18N
        jtfFolderEXTRACT.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfFolderEXTRACTActionPerformed(evt);
            }
        });

        jLabel6.setText(bundle1.getString("SimpleSFE.jLabel6.text")); // NOI18N

        label1.setFont(new java.awt.Font("Dialog", 0, 13)); // NOI18N
        label1.setText(bundle1.getString("SimpleSFE.label1.text")); // NOI18N

        jButton2.setText(bundle1.getString("SimpleSFE.jButton2.text")); // NOI18N
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton4.setText(bundle1.getString("SimpleSFE.jButton4.text")); // NOI18N
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jLabel7.setText(bundle1.getString("SimpleSFE.jLabel7.text")); // NOI18N

        jtfLIMIT.setText(bundle1.getString("SimpleSFE.jtfLIMIT.text")); // NOI18N

        jPanel8.setBackground(java.awt.Color.white);
        jPanel8.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jPanel8.border.title"))); // NOI18N

        jCheckBox1.setSelected(true);
        jCheckBox1.setText(bundle1.getString("SimpleSFE.jCheckBox1.text")); // NOI18N
        jCheckBox1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jCheckBox1MouseClicked(evt);
            }
        });
        jCheckBox1.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                jCheckBox1PropertyChange(evt);
            }
        });

        jcbWT.setText(bundle1.getString("SimpleSFE.jcbWT.text")); // NOI18N
        jcbWT.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                jcbWTPropertyChange(evt);
            }
        });

        jcbDT.setText(bundle1.getString("SimpleSFE.jcbDT.text")); // NOI18N
        jcbDT.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                jcbDTPropertyChange(evt);
            }
        });

        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);
        jPanel8.setLayout(jPanel8Layout);
        jPanel8Layout.setHorizontalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBox1)
                    .addComponent(jcbWT)
                    .addComponent(jcbDT))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel8Layout.setVerticalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addComponent(jCheckBox1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jcbWT)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jcbDT)
                .addContainerGap())
        );

        jPanel9.setBackground(java.awt.Color.white);
        jPanel9.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jPanel9.border.title"))); // NOI18N

        jButton5.setText(bundle1.getString("SimpleSFE.jButton5.text")); // NOI18N
        jButton5.setToolTipText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton5.toolTipText")); // NOI18N
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        jcbONLYSELECTION.setSelected(true);
        jcbONLYSELECTION.setText(bundle1.getString("SimpleSFE.jcbONLYSELECTION.text")); // NOI18N

        jButton3.setText(bundle1.getString("SimpleSFE.jButton3.text")); // NOI18N
        jButton3.setToolTipText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton3.toolTipText")); // NOI18N
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jcbCC.setSelected(true);
        jcbCC.setText(bundle1.getString("SimpleSFE.jcbCC.text")); // NOI18N

        jcbES.setText(bundle1.getString("SimpleSFE.jcbES.text")); // NOI18N

        jButton6.setText(bundle1.getString("SimpleSFE.jButton6.text")); // NOI18N
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });

        jbAnalyseDATA.setText(bundle1.getString("SimpleSFE.jbAnalyseDATA.text")); // NOI18N
        jbAnalyseDATA.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbAnalyseDATAActionPerformed(evt);
            }
        });

        buttonGroup3.add(jrbCCSelector);
        jrbCCSelector.setText(bundle1.getString("SimpleSFE.jrbCCSelector.text")); // NOI18N
        jrbCCSelector.setEnabled(false);

        buttonGroup3.add(jrbIW);
        jrbIW.setSelected(true);
        jrbIW.setText(bundle1.getString("SimpleSFE.jrbIW.text")); // NOI18N

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "raw TS", "semantic norm" }));

        jButton1.setText(bundle1.getString("SimpleSFE.jButton1.text")); // NOI18N
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton12.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton12.text")); // NOI18N
        jButton12.setToolTipText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton12.toolTipText")); // NOI18N
        jButton12.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton12ActionPerformed(evt);
            }
        });

        jButton13.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton13.text")); // NOI18N
        jButton13.setToolTipText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton13.toolTipText")); // NOI18N
        jButton13.setEnabled(false);
        jButton13.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton13ActionPerformed(evt);
            }
        });

        buttonGroup3.add(jRadioButton5);
        jRadioButton5.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jRadioButton5.text")); // NOI18N
        jRadioButton5.setToolTipText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jRadioButton5.toolTipText")); // NOI18N

        jButton14.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton14.text")); // NOI18N
        jButton14.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton14ActionPerformed(evt);
            }
        });

        jcbLOadEditHistory.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jcbLOadEditHistory.text")); // NOI18N

        javax.swing.GroupLayout jPanel9Layout = new javax.swing.GroupLayout(jPanel9);
        jPanel9.setLayout(jPanel9Layout);
        jPanel9Layout.setHorizontalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel9Layout.createSequentialGroup()
                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel9Layout.createSequentialGroup()
                                .addComponent(jcbES)
                                .addGap(53, 53, 53)
                                .addComponent(jcbCC)
                                .addGap(55, 55, 55)
                                .addComponent(jcbLOadEditHistory))
                            .addGroup(jPanel9Layout.createSequentialGroup()
                                .addComponent(jrbIW)
                                .addGap(168, 168, 168)
                                .addComponent(jrbCCSelector)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jRadioButton5))
                            .addGroup(jPanel9Layout.createSequentialGroup()
                                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 254, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(101, 101, 101)
                                .addComponent(jcbONLYSELECTION)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton5, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jButton6, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jbAnalyseDATA, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 254, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(jPanel9Layout.createSequentialGroup()
                        .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(37, 37, 37)
                        .addComponent(jButton12)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButton13)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton14)
                        .addGap(18, 18, 18)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 141, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel9Layout.setVerticalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton5)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jcbES)
                        .addComponent(jcbLOadEditHistory)
                        .addComponent(jcbCC)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton6)
                    .addComponent(jrbIW)
                    .addComponent(jrbCCSelector)
                    .addComponent(jRadioButton5))
                .addGap(1, 1, 1)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jcbONLYSELECTION)
                    .addComponent(jbAnalyseDATA))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton3)
                    .addComponent(jButton12)
                    .addComponent(jButton13)
                    .addComponent(jButton14)
                    .addComponent(jButton1))
                .addGap(47, 47, 47))
        );

        jButton7.setText(bundle1.getString("SimpleSFE.jButton7.text")); // NOI18N
        jButton7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton7ActionPerformed(evt);
            }
        });

        jButton8.setText(bundle1.getString("SimpleSFE.jButton8.text")); // NOI18N
        jButton8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton8ActionPerformed(evt);
            }
        });

        jButton9.setText(bundle1.getString("SimpleSFE.jButton9.text")); // NOI18N
        jButton9.setToolTipText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton9.toolTipText")); // NOI18N
        jButton9.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton9ActionPerformed(evt);
            }
        });

        jRadioButton4.setText(bundle1.getString("SimpleSFE.jRadioButton4.text")); // NOI18N

        jcbADJUST.setSelected(true);
        jcbADJUST.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jcbADJUST.text")); // NOI18N

        buttonGroup2.add(jrbSimpShuffle);
        jrbSimpShuffle.setSelected(true);
        jrbSimpShuffle.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jrbSimpShuffle.text")); // NOI18N

        buttonGroup2.add(jRadioButton6);
        jRadioButton6.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jRadioButton6.text")); // NOI18N

        jButton10.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton10.text")); // NOI18N
        jButton10.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton10ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel10Layout = new javax.swing.GroupLayout(jPanel10);
        jPanel10.setLayout(jPanel10Layout);
        jPanel10Layout.setHorizontalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel10Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jcbADJUST)
                    .addGroup(jPanel10Layout.createSequentialGroup()
                        .addComponent(jrbSimpShuffle)
                        .addGap(18, 18, 18)
                        .addComponent(jRadioButton6)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 43, Short.MAX_VALUE)
                .addComponent(jButton10)
                .addGap(27, 27, 27))
        );
        jPanel10Layout.setVerticalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel10Layout.createSequentialGroup()
                .addGroup(jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel10Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jcbADJUST)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jrbSimpShuffle)
                            .addComponent(jRadioButton6)))
                    .addGroup(jPanel10Layout.createSequentialGroup()
                        .addGap(23, 23, 23)
                        .addComponent(jButton10)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jButton15.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton15.text")); // NOI18N
        jButton15.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton15ActionPerformed(evt);
            }
        });

        jButton16.setText(org.openide.util.NbBundle.getMessage(SimpleSFE.class, "SimpleSFE.jButton16.text")); // NOI18N
        jButton16.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton16ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(label1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jtfFolderEXTRACT, javax.swing.GroupLayout.DEFAULT_SIZE, 548, Short.MAX_VALUE)
                            .addComponent(jtfSTUDIE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jButton4)
                            .addComponent(jButton2))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel7)
                            .addComponent(jLabel1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel3Layout.createSequentialGroup()
                                .addComponent(jtfLIMIT, javax.swing.GroupLayout.PREFERRED_SIZE, 183, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(53, 53, 53)
                                .addComponent(jRadioButton4))
                            .addComponent(jtLF, javax.swing.GroupLayout.PREFERRED_SIZE, 456, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jtfEXTFILE)
                            .addGroup(jPanel3Layout.createSequentialGroup()
                                .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, 367, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(jPanel3Layout.createSequentialGroup()
                                        .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jPanel9, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 829, Short.MAX_VALUE)
                            .addGroup(jPanel3Layout.createSequentialGroup()
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jButton9, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)
                                    .addComponent(jbINSPECT, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(jPanel3Layout.createSequentialGroup()
                                        .addComponent(jLabel5)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(jlZ, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(jPanel3Layout.createSequentialGroup()
                                        .addComponent(jButton15, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(77, 77, 77)
                                        .addComponent(jButton16)))
                                .addGap(112, 112, 112)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jButton7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jButton8, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(0, 0, Short.MAX_VALUE)))
                        .addContainerGap())))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jtfFolderEXTRACT, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel6))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jtfLIMIT, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel7)
                        .addComponent(jButton2)
                        .addComponent(jRadioButton4)))
                .addGap(11, 11, 11)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jtfSTUDIE, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel1)
                        .addComponent(jtLF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jButton4))
                    .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jtfEXTFILE, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jbINSPECT)
                        .addComponent(jLabel5)
                        .addComponent(jlZ))
                    .addComponent(jButton8))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton7)
                    .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jButton9)
                        .addComponent(jButton15)
                        .addComponent(jButton16)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(jPanel3Layout.createSequentialGroup()
                            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(jPanel7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(jPanel9, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        jPanel2.add(jPanel3, java.awt.BorderLayout.PAGE_START);

        jTabbedPane1.addTab(bundle1.getString("SimpleSFE.jPanel2.TabConstraints.tabTitle"), jPanel2); // NOI18N

        jScrollPane1.setViewportView(jTextPane1);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 1728, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 533, Short.MAX_VALUE)
        );

        jTabbedPane1.addTab(bundle1.getString("SimpleSFE.jPanel1.TabConstraints.tabTitle"), jPanel1); // NOI18N

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1728, Short.MAX_VALUE)
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 533, Short.MAX_VALUE)
        );

        jTabbedPane1.addTab(bundle1.getString("SimpleSFE.jPanel4.TabConstraints.tabTitle"), jPanel4); // NOI18N

        getContentPane().add(jTabbedPane1, java.awt.BorderLayout.CENTER);

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle1.getString("SimpleSFE.jPanel5.border.title"))); // NOI18N
        jPanel5.setMinimumSize(new java.awt.Dimension(100, 48));
        jPanel5.setPreferredSize(new java.awt.Dimension(571, 48));

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1737, Short.MAX_VALUE)
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 25, Short.MAX_VALUE)
        );

        getContentPane().add(jPanel5, java.awt.BorderLayout.PAGE_END);

        fileMenu.setMnemonic('f');
        fileMenu.setText(bundle1.getString("SimpleSFE.fileMenu.text")); // NOI18N

        openMenuItem.setMnemonic('o');
        openMenuItem.setText(bundle1.getString("SimpleSFE.openMenuItem.text")); // NOI18N
        fileMenu.add(openMenuItem);

        saveMenuItem.setMnemonic('s');
        saveMenuItem.setText(bundle1.getString("SimpleSFE.saveMenuItem.text")); // NOI18N
        fileMenu.add(saveMenuItem);

        saveAsMenuItem.setMnemonic('a');
        saveAsMenuItem.setText(bundle1.getString("SimpleSFE.saveAsMenuItem.text")); // NOI18N
        fileMenu.add(saveAsMenuItem);

        exitMenuItem.setMnemonic('x');
        exitMenuItem.setText(bundle1.getString("SimpleSFE.exitMenuItem.text")); // NOI18N
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        menuBar.add(fileMenu);

        editMenu.setMnemonic('e');
        editMenu.setText(bundle1.getString("SimpleSFE.editMenu.text")); // NOI18N

        cutMenuItem.setMnemonic('t');
        cutMenuItem.setText(bundle1.getString("SimpleSFE.cutMenuItem.text")); // NOI18N
        editMenu.add(cutMenuItem);

        copyMenuItem.setMnemonic('y');
        copyMenuItem.setText(bundle1.getString("SimpleSFE.copyMenuItem.text")); // NOI18N
        editMenu.add(copyMenuItem);

        pasteMenuItem.setMnemonic('p');
        pasteMenuItem.setText(bundle1.getString("SimpleSFE.pasteMenuItem.text")); // NOI18N
        editMenu.add(pasteMenuItem);

        deleteMenuItem.setMnemonic('d');
        deleteMenuItem.setText(bundle1.getString("SimpleSFE.deleteMenuItem.text")); // NOI18N
        editMenu.add(deleteMenuItem);

        menuBar.add(editMenu);

        helpMenu.setMnemonic('h');
        helpMenu.setText(bundle1.getString("SimpleSFE.helpMenu.text")); // NOI18N

        contentsMenuItem.setMnemonic('c');
        contentsMenuItem.setText(bundle1.getString("SimpleSFE.contentsMenuItem.text")); // NOI18N
        helpMenu.add(contentsMenuItem);

        aboutMenuItem.setMnemonic('a');
        aboutMenuItem.setText(bundle1.getString("SimpleSFE.aboutMenuItem.text")); // NOI18N
        helpMenu.add(aboutMenuItem);

        menuBar.add(helpMenu);

        setJMenuBar(menuBar);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitMenuItemActionPerformed

    private void jbINSPECTActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbINSPECTActionPerformed
        // TODO add your handling code here:
        try {

            reset();
            BucketLoaderTool tool = BucketLoaderTool.getBucketLoaderTool(this);

            tool.GUI_AUTOMODE = jRadioButton4.isSelected();

            Thread t3 = new Thread(tool);
            t3.start();

        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }//GEN-LAST:event_jbINSPECTActionPerformed

    private void jtfSTUDIEFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtfSTUDIEFocusLost
//        // TODO add your handling code here:
//        this.jtfEXTFILE.setText("/user/kamir/wikipedia/corpus/" + this.jtfSTUDIE.getText() + "/part-r-00000");
//        this.jtLF.setText("/home/kamir/bin/WikiExplorer/WikiExplorer/listfile_" + this.jtfSTUDIE.getText() + ".lst");
    }//GEN-LAST:event_jtfSTUDIEFocusLost

    private void jbAnalyseDATAActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbAnalyseDATAActionPerformed
        // TODO add your handling code here:
        try {



            boolean multi = false;

            // Prozedur fr einzelnes File aus dem Cluster ...
            getFileName();
            initFileSystem();
            getMetaDataOnly(multi);

            listContent(Integer.MAX_VALUE, "");

            initListe();

            initGlobalTSBuffer();

            //openFrame4Index(1, multi);

            gtsb.analyseRows();

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }//GEN-LAST:event_jbAnalyseDATAActionPerformed

    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        // TODO add your handling code here:
        String lll = "?";

        boolean multi = true;

        int i = -1;
        if (jcbONLYSELECTION.isSelected()) {
            i = selectCN();
            if (i < 0) {
                javax.swing.JOptionPane.showMessageDialog(this, i + " is < 0 !!! \n\nPlease select CN o switch to multi-mode.");
                return;
            }

            System.out.println("Selection=" + i);


            try {

                lll = loadRowsForSelectionOnly(i);

                extractREP_access(true, i + 1);


            } catch (IOException ex) {
                Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
            }

            this.openFrame4Index(i, multi, lll);
        } else {



            int max = jList1.getModel().getSize();

            String ext = javax.swing.JOptionPane.showInputDialog("Extension:");

            File f = new File("/home/kamir/ANALYSIS/TRI/TRI_" + jtfSTUDIE.getText() + "_" + ext + ".csv");

            FileWriter fw = null;
            try {
                fw = new FileWriter(f);
            } catch (IOException ex) {
                Exceptions.printStackTrace(ex);
            }

            for (int k = 0; k < max; k++) {
                try {
                    i = k;

                    lll = loadRowsForSelectionOnly(k);


                } catch (IOException ex) {
                    Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
                }

                /**
                 * Here we calculate the TRI **
                 */
                boolean multi2 = false;
                this.openFrame4Index2(i, multi2, lll, fw);

            }
            try {
                fw.close();
                System.out.println(">> {" + f.getAbsolutePath() + "} closed.");
            } catch (IOException ex) {
                Exceptions.printStackTrace(ex);
            }
        }






    }//GEN-LAST:event_jButton5ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        try {
            _processLoadedList("all", true);
        } catch (Exception ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public void _processLoadedList(String extension, boolean multi) throws Exception {

        // Ausgabe Datei
        FileWriter fw = null;
        String lfile = jtLF.getText();
        File fff = new File(lfile);
        lfile = fff.getName();

        File fstat = new File("/home/kamir/ANALYSIS/DATA/" + lfile + "." + extension + ".group.analysis.dat");

        System.out.println(">>> RESULT-File : " + fstat.getAbsolutePath());

        fw = new FileWriter(fstat);
        BufferedWriter bw = new BufferedWriter(fw);

        HashSet hs = localNet.codes;
        ArrayList al = new ArrayList();
        for (Object o : hs) {
            al.add(o);
        }
        Collections.sort(al);

        final String hl = "key" + "\t" + "#MR" + "\t" + "SUM(access)" + "\t" + "MW( access )\n";
        System.out.println("[HEADER] " + hl);

        bw.write(hl);

        for (Object k : al) {

            String key = (String) k;

            // totalClick-Count in GROUP
            double sum = 0.0;
            // average ClickCount per time
            double mw = 0.0;

            // nun bekomme ich die Zahl der Reihen in der Gruppe KEY
            int nrRows = 0;

            Vector<Messreihe> cn = hash.get(key);

            String name = key;

            if (cn != null) {

                nrRows = cn.size();

                // System.out.println( key + " " + (cn!=null) + " " + cn.elementAt(0).yValues.size() );
                if (cn.size() > 0) {
                    Messreihe r = cn.elementAt(0);
                    if (r != null) {
                        name = r.label;
                    }

                    sum = summe(cn);
                    mw = sum / new Double(jtL.getText());
                }
            } else {
            }
            DecimalFormat df = new DecimalFormat("0.00");

            String line = key + "\t" + nrRows + "\t" + df.format(sum) + "\t" + df.format(mw) + "\t" + getGroupDetails2(key) + "\t" + getGroupDetails3(key);


            System.out.println(line);
            bw.write(line + "\n");
        }

        bw.flush();
        bw.close();


        _runCN_Analysis(multi);


    }//GEN-LAST:event_jButton1ActionPerformed

    private void jtfSTUDIEActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfSTUDIEActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jtfSTUDIEActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed

        
        String folderName = jtfFolderEXTRACT.getText() + "/corpus";
        JFileChooser jfc3 = new JFileChooser();
        jfc3.setSelectedFile(new File(folderName));
        int i = jfc3.showOpenDialog(this);
        File f = jfc3.getSelectedFile();
        String name = f.getAbsolutePath();

        jtfEXTFILE.setText(name);

        jtfSTUDIE.setText(f.getParentFile().getName());

        if (this.jRadioButton4.isSelected()) {
            // auto mode 
            jButton4ActionPerformed(null);
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed

        String list = jtfSTUDIE.getText();

        int x = list.lastIndexOf("_");
        list = list.substring(0, x);

        x = list.lastIndexOf("_");
        list = list.substring(0, x);

        String studienname = "/ETOSHA.WS/TSDB/raw/wikipedia/metadata" + "/merged_listfile_" + list + ".lst";

        jtLF.setText(studienname);

        File f = new File(studienname);

        if (f.canRead()) {
            jtLF.setBackground(Color.GREEN);
        } else {
            jtLF.setBackground(Color.red);
        }

        if (this.jRadioButton4.isSelected()) {
            jbINSPECTActionPerformed(null);
        }

    }//GEN-LAST:event_jButton4ActionPerformed

    void processWikiFinanceCorrelationAnalys() {
        /**
         * lOAD JUST THIS GROUP ...
         */
        int i = selectCN();

        if (i < 0) {
            return;
        }

        System.out.println(">>> [Selection]=" + i);
        System.out.println(">>> DO a full analysis now ... ");
        
        /**
         * prepare STOCK DATA ...
         */
        Vector<Messreihe> vSTOCKDATA = new Vector<Messreihe>();

        Vector<Messreihe> finanzRow = new Vector<Messreihe>();

        String[] cols = {"Log_Return", "Adj_Close", "Volume"}; // , "Close", }; // , "Adj_Close" , "High", "Low"};

        String labelS = null;
        String name = null;
        for (String s : cols) {

            if (labelS == null) {
                labelS = s;
            } else {
                labelS = labelS.concat(", " + s);
            }
            try {
                sdl.initColumn(s);
            } catch (ParseException ex) {
                Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
            }

            name = nameList.elementAt(i);

            String key = sdl.getHash().get(name);

            int c = 0;
            if (key != null) {
                Messreihe mr = sdl.getMessreihe(key);
                vSTOCKDATA.add(mr);
                finanzRow.add(mr);
                c++;
            } else {
                System.out.println("**** " + name);
            }
            System.out.println("**** total: " + c);
        }

        String[] sdlLabels = sdl.getChartLabels();
        sdlLabels[2] = labelS;
        sdlLabels[0] = "{" + computeMode + "}" + name + " # " + sdlLabels[0];

        /**
         * KONTROLLE der DATEN *
         */
        // MultiChart.open(vSTOCKDATA, sdlLabels[0], sdlLabels[1], sdlLabels[2], true);
        try {

            loadRowsForSelectionOnly(i);

            System.out.println(">>> loaded selected data again ... ");

        } catch (IOException ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        }
//
//        /**
//         * CHARTS ...
//         */
////        if( !jcbCC.isSelected() && ! ) { 
////            System.out.println(">>> open a chart Frame ... ");
////
////            boolean multi = true;
////            this._openFrame4Index(i, multi);
////        }

//        /*
//         *  wiki-network
//         * 
//         */
        System.out.println(">>> Show the localNetwork details ... in the panel");
        // LocalNetFrame.showNetworkForID(i, localNet, this);
//
//
//        java.util.GregorianCalendar von = new java.util.GregorianCalendar();
//        von.clear();
//
//        int jahr = Integer.parseInt(this.jtJAHR.getText());;
//        int monat = Integer.parseInt(this.jtMONAT.getText()) - 1;
//        int tag = Integer.parseInt(this.jtTAG.getText());
//
//        von.set(jahr, monat, tag, 0, 0);
//
////                    java.util.GregorianCalendar bis = new java.util.GregorianCalendar();
////                    bis.clear();
////                    bis.set(2009, 3, 1, 0, 0);
//
//
//        int dt2 = 30;
//        dt2 = Integer.parseInt(this.jtL.getText());
//
//        java.util.GregorianCalendar bis = new java.util.GregorianCalendar();
//        bis.clear();
//        bis.set(jahr, monat, tag, 0, 0);
//        bis.add(GregorianCalendar.DAY_OF_YEAR, dt2);
//
//        WikiHistoryExtraction2.setVon(von);
//        WikiHistoryExtraction2.setBis(bis);
//
//
//        try {
//            System.out.println(">>> process ... the group statistics ... ");
//
//            // works also with HadoopTS framework ... :-) 
//            processLoadedList((i + 1) + "");
//
//            calcEditActivity();
//
//
//
//
//
//
//        } catch (Exception ex) {
//            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
//        }
//
        /**
         *
         * CC-Analyse
         *
         */
        // SCHWELLWERT fr Linkstrke whlen ...
        // NUR SINNVOLL bei normalisierten Verteilungen, deren Mittelpunktslage
        // genau bekannt ist. Ein adaptives Verfahren ist da erforderlich.
        // 
        double ts1 = initTS();
        if (jcbCC.isSelected()) {

            GTSB2.reset();

            System.out.println(">>> process the CC analysis now ... ");

            // finanz & wiki
            int z = Integer.parseInt(this.jTextField1.getText());
            int width = Integer.parseInt(this.jTextField2.getText());
            int shift = Integer.parseInt(this.jTextField3.getText());

            Vector frames = new Vector();
            String chartFrameTitle = "node_" + i + "_FD_tau=" + getTau();

            for (int ix = 0; ix < z; ix++) {
                ///  chartFrameTitle = calcINFOFlowACCESS2(ts1, vSTOCKDATA, ix * shift, ix * shift + width, ix, frames);
            }

            ChartComparisonFrame._addFrames3(frames, chartFrameTitle, "2");

            // intra
            // calcINFOFlowACCESS(ts1);

        }

//        if (jcbES.isSelected()) {
//
//            GTSB2.reset();
//
//            System.out.println(">>> process the ES analysis now ... ");
//
//            calcINFOFlowEDITS(ts1);
//
//        }

    }

    void processMetaCorrelation(String typ, int direction, boolean calcDependencyNetwork) throws IOException {

        OriginProject op = new OriginProject();
        op.initFolder(null);

        /**
         *  defines if we calc:
         * 
         *      MetacorrelationAnalysisV2.calcMetacorrelation(symbol, grC);
         *  
         *  for stock-market data ... (makes only sense if stock market 
         *  related pages are used.
         * 
         *  Significance test: use stock pages and NON stock pages ...
         * 
         */
        boolean modeWikiStock = false;
        if (jRadioButton5.isSelected()) {
            modeWikiStock = true;
        }

        // TODO add your handling code here:

        /**
         * lOAD JUST THIS GROUP ...
         */
        int i = this.jList1.getSelectedIndex();
        System.out.println(">>> [Selection]=" + i);
        System.out.println("> modeWikiStock : " + modeWikiStock);
        System.out.println("> typ           : " + typ);
        System.out.println("> direction     : " + direction);
        System.out.println("> calcDepNet    : " + calcDependencyNetwork);
        System.out.println(">\n>>> DO a full analysis now ... ");

        try {
            
            loadRowsForSelectionOnly(i);
            
            System.out.println(">>> loaded selected data again ... ");
            
        } 
        catch (IOException ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        }

        /*
         *  wiki-network
         * 
         */
        System.out.println(">>> Show the localNetwork details ... in a panel");
        LocalNetFrame.showNetworkForID(i, localNet, this);

        int ii = getSelectionCN();
        ii = ii + 1;  // die Container werden ab 1 gezhlt.

        Vector<Messreihe> grCN = this.hash.get(ii + ".CN");
        Vector<Messreihe> grIWL = this.hash.get(ii + ".IWL");
        Vector<Messreihe> grAL = this.hash.get(ii + ".A.L");
        Vector<Messreihe> grBL = this.hash.get(ii + ".B.L");

        Vector<Messreihe> grA = new Vector<Messreihe>();
        Vector<Messreihe> grB = new Vector<Messreihe>();
        Vector<Messreihe> grC = new Vector<Messreihe>();
        Vector<Messreihe> grD = new Vector<Messreihe>();
        Vector<Messreihe> grDBIG = new Vector<Messreihe>();

        if (typ.equals("D1")) {            
            
            IntraCorrelationAnalysis.sampling = false;            
            grA.addAll(grCN);
            grA.addAll(grIWL);

            grB.addAll(grAL); 
            
        }

        if (typ.equals("D2")) {   
            
            IntraCorrelationAnalysis.sampling = false;
            grA.addAll(grCN);
            grA.addAll(grIWL);
 
            grB.addAll(grBL);
            
        }

        if (typ.equals("C")) {
            
            grB.addAll(grCN);
            grB.addAll(grIWL);

            grA.addAll(grAL);
            grA.addAll(grBL);
            
        }

        if (typ.equals("B")) {
            grA.addAll(grCN);
            grA.addAll(grIWL);

            grB.addAll(grAL);
            grB.addAll(grBL);
        }

        // used for dependency networks
        grD.addAll(grCN);
        grD.addAll(grIWL);
        grD.addAll(grAL);

        grDBIG.addAll(grCN);
        grDBIG.addAll(grIWL);
        grDBIG.addAll(grAL);
        grDBIG.addAll(grBL);

        if (direction == 0) {
            
        } 
        else {
            // SWAP the groups
            Vector<Messreihe> temp = grA;
            grA = grB;
            grB = temp;
        }
        typ = typ + direction;

        // The external influence is expressed by the average value
        Messreihe mrGB = Messreihe.averageForAll(grB);
        Messreihe mrGBlog = null; // Messreihe.averageForLogOfAll(grB);


        // int scale = 24; 
        int scale = 1;

        int tau = 4 * 7;
        int dtau = 7;

        long seed = 1;
        
        stdlib.StdRandom.initRandomGen(seed);

        System.out.println("> seed          : " + seed);
        System.out.println("> scale         : " + scale);
        System.out.println("> tau           : " + tau);
        System.out.println("> dtau          : " + dtau);              
              
        IntraCorrelationAnalysis.op = op;
        MetacorrelationAnalysisV2.op = op;
        
        // NAME der Seite
        String name = "Meta2.";
        String symbol = "";
        
        if (modeWikiStock) {

            // Aktien Messgroesse und ALLE SEITEN
            grC.addAll(grCN);
            grC.addAll(grIWL);

            grC.addAll(grAL);
            grC.addAll(grBL);

            symbol = javax.swing.JOptionPane.showInputDialog("Symbol:", "^GDAXI,^IXIC,^N225,^FTLC,000001.SS,^GSPC,^BSESN");

            name = name + " symbol";
            try {

                //                                            grA   , grB
                MetacorrelationAnalysisV2.calcMetacorrelation(symbol, grC);

            } catch (IOException ex) {
                Exceptions.printStackTrace(ex);
            } catch (ParseException ex) {
                Exceptions.printStackTrace(ex);
            } catch (Exception ex) {
                Exceptions.printStackTrace(ex);
            }
        }

        
        /**
         * call the analysis function ...
         * 
         * instead of all rows in group B we use an average value 
         * (maybe a detrendet or a weighted average later ... )
         * 
         * Messreihe mrGB = Messreihe.averageForAll(groupB);
         */
        boolean shuffle = false;
        
        Vector<Messreihe> result = IntraCorrelationAnalysis._calcIntraCorrelation(grA, grB, tau, dtau, true, shuffle);

        if (calcDependencyNetwork) {

            Vector<Messreihe> netResultRows = IntraCorrelationAnalysis._calcDependcyNetworks(grD, tau, dtau, true, shuffle);

            String title = symbol + " (4) network properties as a function of time (tau=" + tau + " typ=" + typ + ")";
            op.storeChart(netResultRows, true, title, "netdynamics.4_" + typ + "_image1.png");

        }
        
//        if (calcDependencyNetwork) {
//
//            Vector<Messreihe> netResultRows = IntraCorrelationAnalysis.calcDependcyNetworks(grDBIG, tau, dtau, true, shuffle);
//
//            String title = symbol + " (5) network properties as a function of time (tau=" + tau + " typ=" + typ + ")";
//            op.storeChart(netResultRows, true, title, "netdynamics.5_" + typ + "_image1.png");
//
//        }

        String header = "#\n#\tMetaCorrelation \n#\tname: " + name + "\n#\ttype: " + typ + "\n#" + "\n#\tid: " + ii + "\n#";
        String header2 = getTimeString();

        op.setHeader(header);
        op.addToHeader(header2);

        op.addMessreihen(result, "metacorrelation.1_" + typ + "_", true);

        System.out.println(">>> results are stored in: " + op.toString());

        int[] _dt = new int[10];
        _dt[0] = 1;
        _dt[1] = 1;
        _dt[2] = 1;
        _dt[3] = 1;
        _dt[4] = 1;
        _dt[5] = 0;
        _dt[6] = 0;
        _dt[7] = 0;
        _dt[8] = 0;
        _dt[9] = 0;

        MultiChart._setTypes(_dt);

        Color[] col = new Color[10];
        col[0] = Color.BLACK;
        col[1] = Color.BLUE;
        col[2] = Color.GRAY;
        col[3] = Color.ORANGE;
        col[4] = Color.RED;
        col[5] = Color.BLACK;
        col[6] = Color.BLUE;
        col[7] = Color.GRAY;
        col[8] = Color.ORANGE;
        col[9] = Color.RED;

        MultiChart._initColors(col);

        MultiChart.yRangDEFAULT_MIN = -5;
        MultiChart.yRangDEFAULT_MAX = 5;
        MultiChart.xRangDEFAULT_MIN = 0;
        MultiChart.xRangDEFAULT_MAX = getLengthInDays();
        MultiChart.setDefaultRange = true;

        String title = symbol + " (1) C, PC, ICF as a function of tau=" + tau + " typ=" + typ;

        op.storeChart(result, true, title, "metacorrelation.1_" + typ + "_image1.png");
        
        try {
            op.closeAllWriter();
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }

    }

    void processNeighborhoodCorrelation() throws Exception {

        OriginProject op = new OriginProject();
        op.initFolder(null);

        boolean shuffle = true;

        /**
         * lOAD JUST THIS GROUP ...
         */
        int i = this.jList1.getSelectedIndex();
        System.out.println(">>> [Selection]=" + i);

        System.out.println(">>> We do a neighborhood analysis now ... ");

        try {

            loadRowsForSelectionOnly(i);

            System.out.println(">>> loaded selected data again ... ");

        } 
        catch (IOException ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        }

        /*
         *  wiki-network
         * 
         */
        System.out.println(">>> Show the localNetwork details ... in the panel");
        LocalNetFrame.showNetworkForID(i, localNet, this);

//        java.util.GregorianCalendar von = new java.util.GregorianCalendar();
//        von.clear();

//        int jahr = Integer.parseInt(this.jtJAHR.getText());;
//        int monat = Integer.parseInt(this.jtMONAT.getText()) - 1;
//        int tag = Integer.parseInt(this.jtTAG.getText());
//
//        von.set(jahr, monat, tag, 0, 0);
//
////                    java.util.GregorianCalendar bis = new java.util.GregorianCalendar();
////                    bis.clear();
////                    bis.set(2009, 3, 1, 0, 0);
//
//
//        int dt2 = 30;
//        dt2 = Integer.parseInt(this.jtL.getText());
//
//        java.util.GregorianCalendar bis = new java.util.GregorianCalendar();
//        bis.clear();
//        bis.set(jahr, monat, tag, 0, 0);
//        bis.add(GregorianCalendar.DAY_OF_YEAR, dt2);
//
//        WikiHistoryExtraction2.setVon(von);
//        WikiHistoryExtraction2.setBis(bis);



        int ii = getSelectionCN();
        ii = ii + 1;  // die Container werden ab 1 gezhlt.

        Vector<Messreihe> grCN = this.hash.get(ii + ".CN");
        Vector<Messreihe> grIWL = this.hash.get(ii + ".IWL");
        Vector<Messreihe> grAL = this.hash.get(ii + ".A.L");
        Vector<Messreihe> grBL = this.hash.get(ii + ".B.L");

        Vector<Messreihe> grA_L = new Vector<Messreihe>();
        Vector<Messreihe> grB_L = new Vector<Messreihe>();
        Vector<Messreihe> grA_G = new Vector<Messreihe>();
        Vector<Messreihe> grB_G = new Vector<Messreihe>();


        grA_L.addAll(grCN);
//        grA_L.addAll(grIWL);

        grB_L.addAll(grAL);

//        grA_G.addAll(grCN);
        grA_G.addAll(grIWL);

        grB_G.addAll(grBL);


        // int scale = 24; 
        int scale = 1;

        int tau = 4 * 7;
        int dtau = 7;

        stdlib.StdRandom.initRandomGen(1);

        IntraCorrelationAnalysis.op = op;
        MetacorrelationAnalysisV2.op = op;

        // NAME der Seite
        String name = "Neighborhood.3.";
        String symbol = "";

        /**
         * call the analysis function ...
         */
        shuffle = false;
        Vector<Messreihe> resultRowsL = IntraCorrelationAnalysis.calcIntraCorrelation2(grA_L, grB_L, tau, dtau, debug, shuffle);
        shuffle = false;
        Vector<Messreihe> resultRowsG = IntraCorrelationAnalysis.calcIntraCorrelation2(grA_G, grB_G, tau, dtau, debug, shuffle);

        Vector<Messreihe> result = new Vector<Messreihe>();

        resultRowsL.elementAt(0).setLabel("CC_local");
        resultRowsG.elementAt(0).setLabel("CC_global");

        result.add(resultRowsL.elementAt(0));
        result.add(resultRowsG.elementAt(0));

        Messreihe sigmaP = resultRowsG.elementAt(1);
        Messreihe sigmaN = sigmaP.scaleY_2(-1.0);

        Messreihe mrrr = resultRowsG.elementAt(0);
        Messreihe mrU = mrrr.add(sigmaP);
        Messreihe mrL = mrrr.add(sigmaN);

        mrU.setLabel("1sigma+");
        mrL.setLabel("1sigma-");
        result.add(mrU);
        result.add(mrL);

        Messreihe raw = grCN.elementAt(0);
        raw.normalize();
        raw.setLabel("norm(log(access( CN )))");
        result.add(raw);

        String header = "#\n#\tNeighborhoodCorrelation \n#\tname: " + name + "\n#\n#" + "\n#\tid: " + ii + "\n#";
        String header2 = getTimeString();

        op.setHeader(header);
        op.addToHeader(header2);

        op.addMessreihen(result, "Neighborhood.3.", true);

        System.out.println(">>> results are stored in: " + op.toString());

        int[] _dt = new int[10];
        _dt[0] = 1;
        _dt[1] = 1;
        _dt[2] = 0;
        _dt[3] = 0;
        _dt[4] = 2;
        _dt[5] = 0;
        _dt[6] = 0;
        _dt[7] = 0;
        _dt[8] = 0;
        _dt[9] = 0;

        MultiChart._setTypes(_dt);

        Color[] col = new Color[10];
        col[0] = Color.BLACK;
        col[1] = Color.BLUE;
        col[2] = Color.GRAY;
        col[3] = Color.GRAY;

        col[4] = Color.ORANGE;
        col[5] = Color.BLACK;
        col[6] = Color.BLUE;
        col[7] = Color.GRAY;
        col[8] = Color.ORANGE;
        col[9] = Color.RED;

        MultiChart._initColors(col);

        MultiChart.yRangDEFAULT_MIN = -1;
        MultiChart.yRangDEFAULT_MAX = 1;
        MultiChart.xRangDEFAULT_MIN = 0;
        MultiChart.xRangDEFAULT_MAX = 220;
        MultiChart.setDefaultRange = true;

        String title = symbol + " (3) CC local vs. global neighborhood tau=" + tau;

        op.storeChart(result, true, title, "neighborhood.3.image1.png");

        try {
            op.closeAllWriter();
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }

    }

    void _processIntraWikiCorrelationAnalys() {

        // TODO add your handling code here:

        /**
         * lOAD JUST THIS GROUP ...
         */
        int i = this.jList1.getSelectedIndex();
        System.out.println(">>> [Selection]=" + i);

        System.out.println(">>> DO a full analysis now ... ");


        try {

            loadRowsForSelectionOnly(i);

            System.out.println(">>> loaded selected data again ... ");

        } catch (IOException ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        }

        /**
         * CHARTS ...
         */
//        if( !jcbCC.isSelected() && ! ) { 
//            System.out.println(">>> open a chart Frame ... ");
//
//            boolean multi = true;
//            this._openFrame4Index(i, multi);
//        }
        /*
         *  wiki-network
         * 
         */
        System.out.println(">>> Show the localNetwork details ... in the panel");
        // LocalNetFrame.showNetworkForID(i, localNet, this);


        java.util.GregorianCalendar von = new java.util.GregorianCalendar();
        von.clear();

        int jahr = Integer.parseInt(this.jtJAHR.getText());;
        int monat = Integer.parseInt(this.jtMONAT.getText()) - 1;
        int tag = Integer.parseInt(this.jtTAG.getText());

        von.set(jahr, monat, tag, 0, 0);

//                    java.util.GregorianCalendar bis = new java.util.GregorianCalendar();
//                    bis.clear();
//                    bis.set(2009, 3, 1, 0, 0);


        int dt2 = 30;
        dt2 = Integer.parseInt(this.jtL.getText());

        java.util.GregorianCalendar bis = new java.util.GregorianCalendar();
        bis.clear();
        bis.set(jahr, monat, tag, 0, 0);
        bis.add(GregorianCalendar.DAY_OF_YEAR, dt2);

        WikiHistoryExtraction2.setVon(von);
        WikiHistoryExtraction2.setBis(bis);


        try {

            System.out.println(">>>                   von : " + von.getTime().toString());
            System.out.println(">>>                   bis : " + bis.getTime().toString());

            System.out.println(">>> process ... the group statistics ... ");

//            javax.swing.JOptionPane.showMessageDialog(rootPane, "Edit Events ... ");

            // works also with HadoopTS framework ... :-) 
            _processLoadedList((i + 1) + ".groups_stats", true);

            if( jcbLOadEditHistory.isSelected() ) _calcEditActivity();

        } catch (Exception ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        }

        /**
         *
         * CC-Analyse
         *
         */
        // SCHWELLWERT fr Linkstrke whlen ...
        double ts1 = initTS();

        // nur for ACCESS counts mit CC-Analysis
        if (jcbCC.isSelected()) {

            GTSB2.reset();

            System.out.println(">>> process the CC analysis now ... ");

            

            int z = Integer.parseInt(this.jTextField1.getText());
            int width = Integer.parseInt(this.jTextField2.getText());
            int shift = Integer.parseInt(this.jTextField3.getText());

            Vector frames = new Vector();
            String chartFrameTitle = "node_" + i;

//            ProgressDialog dlg = new ProgressDialog( this , false );
//            dlg.setProgress( 0.0 );

            for (int ix = 0; ix < z; ix++) {
                Container[] c = _calcINFOFlowACCESS(ts1, ix * shift, ix * shift + width, ix);
                frames.add(c[0]);
                frames.add(c[1]);
                frames.add(c[2]);

                double progr = ix / z;

                System.err.println("### " + progr + " %");

//                SwingUtilities.invokeLater( new Runnable() {
//                        @Override public void run() {
//                        dlg.setProgress( progr );
//                    }
//                } );

            }

            ChartComparisonFrame._addFrames2(frames, chartFrameTitle);

        }

        // nur Edit-Events mit Event Synchronisation
        if (jcbES.isSelected()) {

            GTSB2.reset();

            System.out.println(">>> process the ES analysis now ... ");
            try {
                calcINFOFlowEDITS(ts1);
            } catch (IOException ex) {
                Exceptions.printStackTrace(ex);
            }

        }

    }

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed

        int k = Integer.parseInt(this.jTextField4.getText());
        int index = k + Integer.parseInt(this.selectedK.getText());

        System.out.println(">>> Index: " + index);

        this.jLabel2.setText("index: " + index);

        this.repaint();

        //javax.swing.JOptionPane.showMessageDialog(this, "k=[" + (-1.0 * k) + "..." + k + "], selected: " + index);

        KreuzKorrelation._defaultK = k;
        
        //CheckInfluenceOfSingelPeaks.ID_TO_SELECT_CC_FROM = index;

        String nodeDATAType = (String) this.jComboBox1.getSelectedItem();

        if (nodeDATAType == null) {
            return;
        }
        this.computeMode = nodeDATAType;
        System.err.println("NDT: " + nodeDATAType);


        if (jrbCCSelector.isSelected()) {
            processWikiFinanceCorrelationAnalys();
        }

        if (jrbIW.isSelected()) {
            _processIntraWikiCorrelationAnalys();
        }
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        // TODO add your handling code here:
        if (cf != null) {
            cf._store(_TEMPlll);
        }
    }//GEN-LAST:event_jButton6ActionPerformed

    private void jButton7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton7ActionPerformed
        // TODO add your handling code here:

        Vector<Messreihe> v = new Vector<Messreihe>();

        String s = javax.swing.JOptionPane.showInputDialog("Col:", "Volume");
        try {
            sdl.initColumn(s);
        } catch (ParseException ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        }


        for (String name : nameHash.values()) {
            System.out.print(name + " # ");
            String s2 = name.substring(5);

            System.out.println(s2);
            String key = sdl.getHash().get(s2);

            int c = 0;
            if (key != null) {
                Messreihe mr = sdl.getMessreihe(key);

                v.add(mr);
                c++;
            } else {
                System.out.println("**** " + s2);
            }
            System.out.println("**** total: " + c);


        }

        String[] sdlLabels = sdl.getChartLabels();

        MultiChart.open(v, sdlLabels[0], sdlLabels[1], sdlLabels[2], true);
    }//GEN-LAST:event_jButton7ActionPerformed

    private void jButton8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton8ActionPerformed

        Vector<Messreihe> vG = new Vector<Messreihe>();
        Vector<Messreihe> vL = new Vector<Messreihe>();

//        for (String s : rawRows.hash.keySet()) {
//            System.out.println("###" + s);
//        }

        for (int i = 0; i < nameHash.size(); i++) {
            Vector<Messreihe> v2 = calcChartsRatio(i, true);
            if (v2 != null) {
                if (v2.size() > 0) {
                    vG.add(v2.elementAt(0));
                }
                if (v2.size() > 1) {
                    vL.add(v2.elementAt(1));
                }

            }
        }

        MultiChart.open(vG, true);
        MultiChart.open(vL, true);


    }//GEN-LAST:event_jButton8ActionPerformed

    private void jButton9ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton9ActionPerformed

        int i = selectCN();

        if (i < 0) {
            return;
        }
        String name = nameListFULL.elementAt(i);

        System.out.print(name + " # ");

        WikiNode wn = new WikiNode(name);

        boolean verbose = true;

        NetDensityCalc ndc = new NetDensityCalc(wn, verbose);
        Thread t = new Thread(ndc);
        t.start();


    }//GEN-LAST:event_jButton9ActionPerformed

    private void jCheckBox1PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jCheckBox1PropertyChange
        // TODO add your handling code here:
        selection = -1;
    }//GEN-LAST:event_jCheckBox1PropertyChange

    private void jcbWTPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jcbWTPropertyChange
        // TODO add your handling code here:
        selection = -1;

    }//GEN-LAST:event_jcbWTPropertyChange

    private void jcbDTPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jcbDTPropertyChange
        // TODO add your handling code here:
        selection = -1;

    }//GEN-LAST:event_jcbDTPropertyChange

    private void jtLKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtLKeyPressed
        // TODO add your handling code here:
        selection = -1;
    }//GEN-LAST:event_jtLKeyPressed

    private void jCheckBox1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jCheckBox1MouseClicked
        // TODO add your handling code here:
        selection = -1;
    }//GEN-LAST:event_jCheckBox1MouseClicked

    private void jButton10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton10ActionPerformed
        // TODO add your handling code here:
        KreuzKorrelation._DO_CALC_ADJUSTED = jcbADJUST.isSelected();
        KreuzKorrelation.DO_CALC_ADJUSTED_SimpleShuffle = jrbSimpShuffle.isSelected();
        KreuzKorrelation.DO_CALC_ADJUSTED_FFT_PR = !jrbSimpShuffle.isSelected();

    }//GEN-LAST:event_jButton10ActionPerformed

    private void jButton11ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton11ActionPerformed



        java.util.GregorianCalendar von = new java.util.GregorianCalendar();
        von.clear();

        int jahr = Integer.parseInt(this.jtJAHR.getText());;
        int monat = Integer.parseInt(this.jtMONAT.getText()) - 1;
        int tag = Integer.parseInt(this.jtTAG.getText());

        von.set(jahr, monat, tag, 0, 0);

        int dt2 = 30;
        dt2 = Integer.parseInt(this.jtL.getText());

        java.util.GregorianCalendar bis = new java.util.GregorianCalendar();
        bis.clear();
        bis.set(jahr, monat, tag, 0, 0);
        bis.add(GregorianCalendar.DAY_OF_YEAR, dt2);

        String check = "von: " + von.getTime().toString() + "\nbis: " + bis.getTime().toString();

        javax.swing.JOptionPane.showMessageDialog(this, check);

    }//GEN-LAST:event_jButton11ActionPerformed

    
    // MC Mode C
    private void jButton12ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton12ActionPerformed
        try {
            
            int k = Integer.parseInt(this.jTextField4.getText());
            int index = k + Integer.parseInt(this.selectedK.getText());
            System.out.println(">>> Index: " + index);
            
            this.jLabel2.setText("index: " + index);
            
            this.repaint();
            
            javax.swing.JOptionPane.showMessageDialog(this, "k=[" + (-1.0 * k) + "..." + k + "], selected: " + index);
            
            KreuzKorrelation._defaultK = k;
            
            String nodeDATAType = (String) this.jComboBox1.getSelectedItem();
            
            if (nodeDATAType == null) {
                return;
            }
            this.computeMode = nodeDATAType;
            System.err.println("NDT: " + nodeDATAType);
            
            
            String mode = javax.swing.JOptionPane.showInputDialog("Mode: (D1,D2,B,C)");
            
            int direction = 0;  // NO SWITCH IN DIRECTION
            
            processMetaCorrelation(mode, direction, false);  // True:  Calc Dep Network
            
        } 
        catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }




    }//GEN-LAST:event_jButton12ActionPerformed

    // MC Mode B
    private void jButton13ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton13ActionPerformed
        try {
            // TODO add your handling code here:
            
            
            
            int k = Integer.parseInt(this.jTextField4.getText());
            int index = k + Integer.parseInt(this.selectedK.getText());
            System.out.println(">>> Index: " + index);
            
            this.jLabel2.setText("index: " + index);
            
            this.repaint();
            
            javax.swing.JOptionPane.showMessageDialog(this, "k=[" + (-1.0 * k) + "..." + k + "], selected: " + index);
            
            KreuzKorrelation._defaultK = k;
//        CheckInfluenceOfSingelPeaks.ID_TO_SELECT_CC_FROM = index;
            
            String nodeDATAType = (String) this.jComboBox1.getSelectedItem();
            
            if (nodeDATAType == null) {
                return;
            }
            this.computeMode = nodeDATAType;
            System.err.println("NDT: " + nodeDATAType);
            
            String mode = javax.swing.JOptionPane.showInputDialog("Mode:");
            
            int direction = 1;
            processMetaCorrelation(mode, direction, false);
        
        } 
        catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }


    }//GEN-LAST:event_jButton13ActionPerformed

    /**
     * Button: Neighborhood Correlation
     * 
     * For a selected CN (at time index index k) 
     * @param evt 
     */
    private void jButton14ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton14ActionPerformed


        try {
       
            int k = Integer.parseInt(this.jTextField4.getText());
            int index = k + Integer.parseInt(this.selectedK.getText());
            
            System.out.println(">>> Index: " + index);
            
            this.jLabel2.setText("index: " + index);
            
            this.repaint();
            
            javax.swing.JOptionPane.showMessageDialog(this, "k=[" + (-1.0 * k) + "..." + k + "], selected: " + index);
            
            KreuzKorrelation._defaultK = k;
            
            // Selection options are:
            //
            //      raw TS
            //      semantic norm
            
            String nodeDATAType = (String) this.jComboBox1.getSelectedItem();
            
            if (nodeDATAType == null) {
                return;
            }
            
            this.computeMode = nodeDATAType;
            System.err.println("nodeDATAType : " + nodeDATAType);
            
            System.out.println(">>> calculate NEIGHBORHOOD correlation ...  ");
            
            processNeighborhoodCorrelation();
            
        } 
        catch (Exception ex) {
            Exceptions.printStackTrace(ex);
        }

    }//GEN-LAST:event_jButton14ActionPerformed

    private void jButton15ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton15ActionPerformed
    
        
        
        
    }//GEN-LAST:event_jButton15ActionPerformed

    private void jtJAHRActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtJAHRActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jtJAHRActionPerformed

    private void jButton16ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton16ActionPerformed
        try {
            // TODO add your handling code here:
            _loadRowsWithLimit();
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        } catch (NumberFormatException ex) {
            Exceptions.printStackTrace(ex);
        }
    }//GEN-LAST:event_jButton16ActionPerformed

    private void jtfFolderEXTRACTActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfFolderEXTRACTActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jtfFolderEXTRACTActionPerformed

    
    HaeufigkeitsZaehlerDouble linksA = null;
    HaeufigkeitsZaehlerDouble linksB = null;
    Vector<Messreihe> mrKK = null;

    public void initCOunter() {
        linksA = new HaeufigkeitsZaehlerDouble();
        linksA.min = -50;
        linksA.max = 50;
        linksA.intervalle = 100;

        linksB = new HaeufigkeitsZaehlerDouble();
        linksB.min = -0.8;
        linksB.max = 0.8;
        linksB.intervalle = 100;

        mrKK = new Vector<Messreihe>();
        counts = 0;

    }
    int counts = 0;

    public void calcCC(Messreihe mr1, Messreihe mr2) throws Exception {

        if (mr1 != null && mr2 != null) {
            if (mr1.isNotEmpty() && mr2.isNotEmpty()) {
                ExtendedNodePair np = new ExtendedNodePair(mr1, mr2);

                CheckInfluenceOfSingelPeaks.mode = CheckInfluenceOfSingelPeaks.mode_CC_TAU_0;

                try {
                    KreuzKorrelation.setK(5);
                    KreuzKorrelation kk = np.calcCrossCorrelation();

                    np.getLinkStrength();

                    linksA.addData(np.getLinkA());
                    linksB.addData(np.getLinkB());

                    System.out.println(np.toString());
                    String line = np.toString();

                    if (line != null) {
                        //    bw.write(line + "\n");
                    }

                    mrKK.add(kk);
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        } else {
        }
    }

    private void _processDataE(Vector<Messreihe> grCN, Vector<Messreihe> grIWL, Vector<Messreihe> grAL, Vector<Messreihe> grBL, boolean shuffle, FileWriter fw) {

        System.out.println("Calc Event-Synchronisation ... [shuffle=" + shuffle + "]");

        suggestA = new Vector<ExtendedNodePairSFE>();
        suggestB = new Vector<ExtendedNodePairSFE>();
        suggestC = new Vector<ExtendedNodePairSFE>();

        suggestD = new Vector<ExtendedNodePairSFE>();
        suggestE = new Vector<ExtendedNodePairSFE>();
        suggestF = new Vector<ExtendedNodePairSFE>();


        // FROM CN to ALL
        zA = ESProcessor2.getAll(grCN.elementAt(0), grIWL, shuffle, fw, "grIWL")[0];
        zB = ESProcessor2.getAll(grCN.elementAt(0), grAL, shuffle, fw, "grAL")[0];
        zC = ESProcessor2.getAll(grCN.elementAt(0), grBL, shuffle, fw, "grBL")[0];

        // FROM A to B ALL
        zD = ESProcessor2.getPartial(grAL, grIWL, shuffle, ts, suggestA, fw, "grAL.IWL")[0];
        zE = ESProcessor2.getPartial(grBL, grIWL, shuffle, ts, suggestB, fw, "grBL.IWL")[0];
        zF = ESProcessor2.getPartial(grAL, grBL, shuffle, ts, suggestC,fw, "grAL.BL")[0];

        zG = ESProcessor2.getPartial(grAL, grAL, shuffle, ts, suggestD, fw, "grAL.AL")[0];
        zH = ESProcessor2.getPartial(grBL, grBL, shuffle, ts, suggestE, fw, "grBL.BL")[0];
        zI = ESProcessor2.getPartial(grIWL, grIWL, shuffle, ts, suggestF, fw, "grIWL.IWL")[0];



    }

    /**
     * TODO : beachte hier, dass die TS gleich der TS fuer CC ist.
     *
     * @param ts
     */
    public void calcINFOFlowEDITS(double ts) throws IOException {

        int i = getSelectionCN();
        i = i + 1;  // die Container werden ab 1 gezhlt.

        Vector<Messreihe> grCN = this.hash.get(i + ".CN");
        Vector<Messreihe> grIWL = this.hash.get(i + ".IWL");
        Vector<Messreihe> grAL = this.hash.get(i + ".A.L");
        Vector<Messreihe> grBL = this.hash.get(i + ".B.L");



        String name = grCN.elementAt(0).getLabel();

        stdlib.StdRandom.initRandomGen(1);

        System.out.println(">>> INFO Flow EDITS <<<\n>>>");
        System.out.println(">>> Processing : " + i + " now. [" + name + "]");
        System.out.println(">   CN         : " + grCN.size());
        System.out.println(">   IWL        : " + grIWL.size());
        System.out.println(">   AL         : " + grAL.size());
        System.out.println(">   BL         : " + grBL.size());
        System.out.println(">   ts         : " + ts);

        Color[] c = new Color[6];
        c[0] = Color.black;
        c[1] = Color.blue;
        c[2] = Color.red;
        c[3] = Color.black;
        c[4] = Color.blue;
        c[5] = Color.red;
        MultiChartDistComp.initColors(c);

        int[] t = new int[6];
        t[0] = 1;
        t[1] = 1;
        t[2] = 1;
        t[3] = 0;
        t[4] = 0;
        t[5] = 0;
        MultiChartDistComp.setTypes(t);

        Messreihe[] r = new Messreihe[6];
        Messreihe[] r2 = new Messreihe[6];
        Messreihe[] r3 = new Messreihe[6];

        name = name.replace( "/", "_");
        
        FileWriter fw = new FileWriter(new File("EdgeList_ES_" + name + ".csv"));

        _processDataE(grCN, grIWL, grAL, grBL, false, fw);

        r[0] = zA.getHistogramNORM("es (CN,IWL)");
        r[1] = zB.getHistogramNORM("es (CN,AL)");
        r[2] = zC.getHistogramNORM("es (CN,BL)");

        r2[0] = zD.getHistogramNORM("es (AL,IWL)");
        r2[1] = zE.getHistogramNORM("es (BL,IWL)");
        r2[2] = zF.getHistogramNORM("es (AL,BL)");

        r3[0] = zG.getHistogramNORM("es (AL,AL)");
        r3[1] = zH.getHistogramNORM("es (BL,BL)");
        r3[2] = zI.getHistogramNORM("es (IWL,IWL)");

//        _showSuggestions(suggestA, "raw A I" );
//        _showSuggestions(suggestB, "raw B I" );
//        _showSuggestions(suggestC, "raw A B" );
//
//        _showSuggestions(suggestD, "raw A A" );
//        _showSuggestions(suggestE, "raw B B" );
//        _showSuggestions(suggestF, "raw I I" );

        _processDataE(grCN, grIWL, grAL, grBL, true, fw);

        fw.flush();
        fw.close();

        r[3] = zA.getHistogramNORM("es *CN,IWL*");
        r[4] = zB.getHistogramNORM("es *CN,AL*");
        r[5] = zC.getHistogramNORM("es *CN,BL*");

        r2[3] = zD.getHistogramNORM("es *AL,IWL*");
        r2[4] = zE.getHistogramNORM("es *BL,IWL*");
        r2[5] = zF.getHistogramNORM("es *AL,BL*");

        r3[3] = zG.getHistogramNORM("es *AL,AL*");
        r3[4] = zH.getHistogramNORM("es *BL,BL*");
        r3[5] = zI.getHistogramNORM("es *IWL,IWL*");

        MultiChartDistComp.setDefaultRange = true;
        MultiChartDistComp.xRangDEFAULT_MAX = 50.0;
        MultiChartDistComp.xRangDEFAULT_MIN = -50.0;
        MultiChartDistComp.yRangDEFAULT_MIN = 0.0;
        MultiChartDistComp.yRangDEFAULT_MAX = 1.0;

        MultiChartDistComp.open(r, "ES :: CN -> connected", "Q", "nr of links", true);
        MultiChartDistComp.open(r2, "ES :: inter groups ", "Q", "nr of links", true);
        MultiChartDistComp.open(r3, "ES :: INTRA groups", "Q", "nr of links", true);


        String folder = "./data/out/";
        String tsr = getTSRange();

        String fn1 = tsr + name + "_ES1";
        String fn2 = tsr + name + "_ES2";
        String fn3 = tsr + name + "_ES3";

        MultiChartDistComp.openAndStore(r, "ES :: CN -> connected", "Q", "nr of links", true, folder, fn1, "");
        MultiChartDistComp.openAndStore(r2, "ES :: inter groups ", "Q", "nr of links", true, folder, fn2, "");
        MultiChartDistComp.openAndStore(r3, "ES :: INTRA groups", "Q", "nr of links", true, folder, fn3, "");

        /**
         * STORE SUCH LISTS in a external FILE ...
         */
        int uu = 0;
        for (ExtendedNodePairSFE p : linked) {
            uu++;
            System.out.println(uu + "+" + p.toString());
        }

        int ii = 0;
        for (ExtendedNodePairSFE p : notLinked) {
            ii++;
            System.out.println(ii + "-" + p.toString());

        }

        System.out.println("\n" + "*******");

        System.out.println("-" + ii);
        System.out.println("+" + uu);

        /**
         * RESET internal memory ....
         */
    }
    int selected = 1;

    public int getSelectionCN() {
        // TODO add your handling code here:
        int i = selected;
        if (jList1.getSelectedValue() == null) {
            String si = javax.swing.JOptionPane.showInputDialog(this, "Your choice : ", i);
            i = Integer.parseInt(si);
            i = i - 1; // damit es das selbe ist wie der List-Index ...
        } else {
            i = this.jList1.getSelectedIndex();
        }
        selected = i;
        return i;
    }
    double ts = 0.7;
    static HaeufigkeitsZaehlerDoubleSIMPLE zA = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zB = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zC = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zD = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zF = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zG = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zH = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zI = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zAE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zBE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zCE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zDE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zEE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zFE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zGE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zHE = null;
    static HaeufigkeitsZaehlerDoubleSIMPLE zIE = null;
    // public Messreihe[] getRows Vector<Messreihe>
    Vector<ExtendedNodePairSFE> suggestA = null;
    Vector<ExtendedNodePairSFE> suggestB = null;
    Vector<ExtendedNodePairSFE> suggestC = null;
    Vector<ExtendedNodePairSFE> suggestD = null;
    Vector<ExtendedNodePairSFE> suggestE = null;
    Vector<ExtendedNodePairSFE> suggestF = null;

    /**
     *
     * NO PARALLEL CODE HERE !!!!!!!!!
     *
     *
     *
     * @param grCN
     * @param grIWL
     * @param grAL
     * @param grBL
     * @param shuffle
     * @param ndc
     * @param runID
     * @throws IOException
     *
     *
     */
    private void processDataA(Vector<Messreihe> grCN,
            Vector<Messreihe> grIWL,
            Vector<Messreihe> grAL,
            Vector<Messreihe> grBL,
            boolean shuffle,
            NetDensityCalc ndc,
            int runID) throws IOException {

        String kkType = KreuzKorrelation.getCalcTypeLabel();

        BufferedWriter bwFINAL = ndc.logToCCFile("/media/SDA/TEMP/FINAL.CC.INFOFLOW." + shuffle + "." + kkType + "." + runID);

        suggestA = new Vector<ExtendedNodePairSFE>();
        suggestB = new Vector<ExtendedNodePairSFE>();
        suggestC = new Vector<ExtendedNodePairSFE>();

        suggestD = new Vector<ExtendedNodePairSFE>();
        suggestE = new Vector<ExtendedNodePairSFE>();
        suggestF = new Vector<ExtendedNodePairSFE>();

        StringBuffer data = new StringBuffer("#***** shuffle=" + shuffle + " *****\n");
        data.append("#*****      ts=" + ts + " *****\n");

        ResultManager.resetCounter();

        // cc - analyse
        zA = CCProzessor.getAll(grCN.elementAt(0), grIWL, shuffle, ndc, "zA", ts, null, bwFINAL, runID);
        zB = CCProzessor.getAll(grCN.elementAt(0), grAL, shuffle, ndc, "zB", ts, null, bwFINAL, runID);
        zC = CCProzessor.getAll(grCN.elementAt(0), grBL, shuffle, ndc, "zC", ts, null, bwFINAL, runID);
        data.append("#zA.size : " + zA.dists.size() + "\t# zA(i) > ts =>" + zA.getValueAboveTS(ts) + "\n");
        data.append("#zB.size : " + zB.dists.size() + "\t# zB(i) > ts =>" + zB.getValueAboveTS(ts) + "\n");
        data.append("#zC.size : " + zC.dists.size() + "\t# zC(i) > ts =>" + zC.getValueAboveTS(ts) + "\n");

        boolean useRECOMMENDATION = false;

        zD = CCProzessor.getPartial(grIWL, grIWL, shuffle, ts, suggestA, ndc, "zD", bwFINAL, runID, useRECOMMENDATION);
        zE = CCProzessor.getPartial(grAL, grAL, shuffle, ts, suggestB, ndc, "zE", bwFINAL, runID, useRECOMMENDATION);
        zF = CCProzessor.getPartial(grBL, grBL, shuffle, ts, suggestC, ndc, "zF", bwFINAL, runID, useRECOMMENDATION);

        data.append("#zD.size : " + zD.dists.size() + "\t# zD(i) > ts =>" + zD.getValueAboveTS(ts) + "\n");
        data.append("#zE.size : " + zE.dists.size() + "\t# zE(i) > ts =>" + zE.getValueAboveTS(ts) + "\n");
        data.append("#zF.size : " + zF.dists.size() + "\t# zF(i) > ts =>" + zF.getValueAboveTS(ts) + "\n");

        zG = CCProzessor.getPartial(grIWL, grAL, shuffle, ts, suggestD, ndc, "zG", bwFINAL, runID, useRECOMMENDATION);
        zH = CCProzessor.getPartial(grIWL, grBL, shuffle, ts, suggestE, ndc, "zH", bwFINAL, runID, useRECOMMENDATION);
        zI = CCProzessor.getPartial(grAL, grBL, shuffle, ts, suggestF, ndc, "zI", bwFINAL, runID, useRECOMMENDATION);

        data.append("#zG.size : " + zG.dists.size() + "\t# zG(i) > ts =>" + zG.getValueAboveTS(ts) + "\n");
        data.append("#zH.size : " + zH.dists.size() + "\t# zH(i) > ts =>" + zH.getValueAboveTS(ts) + "\n");
        data.append("#zI.size : " + zI.dists.size() + "\t# zI(i) > ts =>" + zI.getValueAboveTS(ts) + "\n");

        data.append("#\n");

        try {
            ndc.logToAnalysisFile(data.toString(), "CC.INFOFLOW." + shuffle);
        } catch (Exception ex) {
            Logger.getLogger(AdvancedSequenceFileExplorer.class.getName()).log(Level.SEVERE, null, ex);
        }

        bwFINAL.flush();
        bwFINAL.close();

        ResultManager.resetCounter();


    }
    static Vector<ExtendedNodePairSFE> linked = new Vector<ExtendedNodePairSFE>();
    static Vector<ExtendedNodePairSFE> notLinked = new Vector<ExtendedNodePairSFE>();

    /**
     *
     * Normale Prozedur mit einer Linkstrken-Schwelle
     *
     *
     *
     * public String _calcINFOFlowACCESS2(double ts1, Vector<Messreihe>
     * finanzRow, int von, int bis, int runID, Vector frames) {
     *
     * String label = null;
     *
     * KreuzKorrelation.von = von; KreuzKorrelation.bis = bis;
     * KreuzKorrelation.chop = true;
     *
     *
     * Vector<Messreihe> ccrMESS = new Vector<Messreihe>(); Vector<Messreihe>
     * ccrRAND = new Vector<Messreihe>();
     *
     * for (Messreihe fW : finanzRow) {
     *
     *
     * int i = getSelectionCN(); i = i + 1; // die Container werden ab 1
     * gezhlt.
     *
     *
     * // Vector<Messreihe> grCNFD = new Vector<Messreihe>(); // grCNFD.add(
     * finanzRow.elementAt(0) );
     *
     *
     *
     * Vector<Messreihe> grCN = this.hash.get(i + ".CN"); Vector<Messreihe>
     * grIWL = this.hash.get(i + ".IWL"); Vector<Messreihe> grAL =
     * this.hash.get(i + ".A.L"); Vector<Messreihe> grBL = this.hash.get(i +
     * ".B.L");
     *
     * // NAME der Seite
     *
     *
     * if (grCN.size() < 1) { javax.swing.JOptionPane.showMessageDialog(this,
     * "no CN available ..."); return "NO CN data"; } // HIER die NORMIERUNG
     * bestimmen ... raw = 1, semantic detrending = // average( environmen )
     *
     * // final Vector<Messreihe> norms = _getNormierung(i); String name =
     * this.hash.get(i + ".CN").elementAt(0).getLabel();
     *
     * System.out.println("name=" + name);
     *
     * WikiNode wn = WikiNode.createFromKeyName(name);
     *
     * System.out.println(">>> Calc the Density of the Network ... \n");
     *
     * NetworkDensiteyCalculator _ndc = new NetworkDensiteyCalculator(wn); //
     * ndc.doit( wn , true, true );
     *
     *
     *
     *
     * System.out.println(">>> INFO Flow ACCESS <<<\n>>>");
     * System.out.println(">>> Processing CN_" + i + " now. name={" + name +
     * "}");
     *
     * System.out.println("> We have data for: ");
     *
     * System.out.println("> CN : " + grCN.size()); System.out.println("> IWL :
     * " + grIWL.size()); System.out.println("> AL : " + grAL.size());
     * System.out.println("> BL : " + grBL.size());
     *
     * stdlib.StdRandom.initRandomGen(1);
     *
     *
     *
     *
     *
     *
     * System.out.println("> threshold = " + ts1);
     *
     * Color[] c = new Color[6]; c[0] = Color.black; c[1] = Color.blue; c[2] =
     * Color.red; c[3] = Color.black; c[4] = Color.blue; c[5] = Color.red;
     *
     * int[] dt = {0, 0, 0, 1, 1, 1};
     *
     * MultiChartDistComp.setTypes(dt);
     *
     * MultiChartDistComp.initColors(c);
     *
     * int[] t = new int[6]; t[0] = 1; t[1] = 1; t[2] = 1; t[3] = 0; t[4] = 0;
     * t[5] = 0;
     *
     * MultiChartDistComp.setTypes(t);
     *
     * Messreihe[] r = new Messreihe[6]; Messreihe[] r2 = new Messreihe[6];
     * Messreihe[] r3 = new Messreihe[6];
     *
     *
     * // hier nun die normierungs funktion mitgeben ODER: null
     *
     * Messreihe rr1 = processDataA2(grCN, fW, grIWL, grAL, grBL, false, _ndc,
     * norms);
     *
     * rr1.setLabel(fW.getLabel()); ccrMESS.add(rr1); // JUST LINKED r[0] =
     * zA.getHistogramNORM("[a] cc(CN,IWL)"); r[1] = zB.getHistogramNORM("[b]
     * cc(CN,AL)"); r[2] = zC.getHistogramNORM("(c) cc(CN,BL)");
     *
     * // ALL PAIRS // r2[0] = zD.getHistogramNORM("(d) cc(IWL,IWL)"); // r2[1]
     * = zE.getHistogramNORM("(e) cc(AL,AL)"); // r2[2] =
     * zF.getHistogramNORM("(f) cc(BL,BL)"); // // // ALL PAIRS // r3[0] =
     * zG.getHistogramNORM("(g) cc(IWL,AL)"); // r3[1] =
     * zH.getHistogramNORM("(h) cc(IWL,BL)"); // r3[2] =
     * zI.getHistogramNORM("(h) cc(AL,BL)");
     *
     *
     * // _showSuggestions(suggestA, "raw A I" ); // _showSuggestions(suggestB,
     * "raw B I" ); // _showSuggestions(suggestC, "raw A B" ); // //
     * _showSuggestions(suggestD, "raw A A" ); // _showSuggestions(suggestE,
     * "raw B B" ); // _showSuggestions(suggestF, "raw I I" ); // Messreihe rr =
     * processDataA2(grCN, fW, grIWL, grAL, grBL, true, _ndc, norms);
     * rr.setLabel("***" + fW.getLabel());
     *
     * ccrRAND.add(rr);
     *
     * // JUST LINKED r[3] = zA.getHistogramNORM("[a] cc(CN,IWL)"); r[4] =
     * zB.getHistogramNORM("[b] cc(CN,AL)"); r[5] = zC.getHistogramNORM("(c)
     * cc(CNL,BL)");
     *
     * // // ALL PAIRS // r2[3] = zD.getHistogramNORM("(d) cc(IWL,IWL)"); //
     * r2[4] = zE.getHistogramNORM("(e) cc(AL,AL)"); // r2[5] =
     * zF.getHistogramNORM("(f) cc(IWL,BL)"); // // // ALL PAIRS // r3[3] =
     * zG.getHistogramNORM("(g) cc(IWL,AL)"); // r3[4] =
     * zH.getHistogramNORM("(h) cc(IWL,BL)"); // r3[5] =
     * zI.getHistogramNORM("(h) cc(AL,BL)");
     *
     *
     * MultiChartDistComp.setDefaultRange = true;
     * MultiChartDistComp.xRangDEFAULT_MAX = 50.0;
     * MultiChartDistComp.xRangDEFAULT_MIN = -50.0;
     * MultiChartDistComp.yRangDEFAULT_MIN = 0.0;
     * MultiChartDistComp.yRangDEFAULT_MAX = 1.0;
     *
     * MultiChartDistComp.setSymbols();
     *
     * // HIER MUSS ICH DANN ZHLEN ... * // MultiChartDistComp.open(r, runID +
     * " [" + name + "] " + fW.getLabel(), "link strength", "nr of links",
     * true); // MultiChartDistComp.open(r2, "[" + name + "] all pairs (INTRA)",
     * "link strength", "nr of links", true); // MultiChartDistComp.open(r3, "["
     * + name + "] all pairs (INTER)", "link strength", "nr of links", true);
     *
     * String folder = "./data/out/";
     *
     * String tsr = getTSRange();
     *
     * String fn1 = tsr + name + "_CC1." + computeMode + "." + runID + ".fd";
     * String fn2 = tsr + name + "_CC2." + computeMode + "." + runID + ".fd";
     * String fn3 = tsr + name + "_CC3." + computeMode + "." + runID + ".fd";
     *
     * label = fn1;
     *
     * Container cont = MultiChartDistComp.openAndStore(r, runID + "[" + name +
     * "] " + fW.getLabel(), "link strength", "nr of links", true, folder, fn1,
     * "."); // MultiChartDistComp.openAndStore(r2, "[" + name + "] all pairs
     * (INTRA)", "link strength", "nr of links", true, folder, fn2, "."); //
     * MultiChartDistComp.openAndStore(r3, "[" + name + "] all pairs (INTER)",
     * "link strength", "nr of links", true, folder, fn3, ".");
     * frames.add(cont);
     *
     * _ndc.flushNetworks(runID); // // STORE SUCH LISTS in a external FILE ...
     * // int uu = 0; for (ExtendedNodePairSFE p : linked) { uu++;
     * System.out.println(uu + "+" + p.toString()); }
     *
     * int ii = 0; for (ExtendedNodePairSFE p : notLinked) { ii++;
     * System.out.println(ii + "-" + p.toString());
     *
     * }
     *
     * System.out.println("\n" + "*******");
     *
     * System.out.println("-" + ii); System.out.println("+" + uu); } // // RESET
     * internal memory .... // MultiChart.open(ccrMESS, "[" + runID + "]
     * wiki-stock market", "k", "CC", true); MultiChart.open(ccrRAND, "(" +
     * runID + ")* wiki-stock market", "k", "*CC", true); return label;
     *
     * }
     *
     */
    /**
     *
     * Normale Prozedur mit einer Linkstrken-Schwelle
     *
     *
     */
    public Container[] _calcINFOFlowACCESS(double _ts1, int von, int bis, int runID) {


        KreuzKorrelation.von = von;
        KreuzKorrelation.bis = bis;
        KreuzKorrelation.chop = true;

        int i = getSelectionCN();
        i = i + 1;  // die Container werden ab 1 gezhlt.

        Vector<Messreihe> grCN = this.hash.get(i + ".CN");
        Vector<Messreihe> grIWL = this.hash.get(i + ".IWL");
        Vector<Messreihe> grAL = this.hash.get(i + ".A.L");
        Vector<Messreihe> grBL = this.hash.get(i + ".B.L");

        // NAME der Seite
        String name = grCN.elementAt(0).getLabel();

        System.out.println("name=" + name);

        WikiNode wn = WikiNode.createFromKeyName(name);

        System.out.println(">>> Calc the Density of the Network ... \n");

        NetDensityCalc _ndc = new NetDensityCalc(wn, false);
        _ndc.setNetwork(localNet);

//        ndc.doit( wn );

        System.out.println(">>> INFO Flow ACCESS <<<\n>>>");
        System.out.println(">>> Processing CN_" + i + " now. name={" + name + "}");

        System.out.println("> We have data for: ");

        System.out.println(">   CN         : " + grCN.size());
        System.out.println(">   IWL        : " + grIWL.size());
        System.out.println(">   AL         : " + grAL.size());
        System.out.println(">   BL         : " + grBL.size());

        stdlib.StdRandom.initRandomGen(1);

        System.out.println(">   threshold = " + _ts1);

        Color[] c = new Color[6];
        c[0] = Color.black;
        c[1] = Color.blue;
        c[2] = Color.red;
        c[3] = Color.black;
        c[4] = Color.blue;
        c[5] = Color.red;

//        int[] dt = {0, 0, 0, 1, 1, 1};
//
//        MultiChartDistComp.setTypes(dt);

        MultiChartDistComp.initColors(c);
        
//        if( ! KreuzKorrelation._DO_CALC_ADJUSTED) {
//            MultiChartDistComp.xRangDEFAULT_MIN = -1.0;
//            MultiChartDistComp.xRangDEFAULT_MAX = 1.0;
//            MultiChartDistComp.yRangDEFAULT_MIN = 0.0;
//            MultiChartDistComp.yRangDEFAULT_MAX = 1.0;
//        }
        
        int[] t = new int[6];
        t[0] = 1;
        t[1] = 1;
        t[2] = 1;
        t[3] = 1;
        t[4] = 1;
        t[5] = 1;

        MultiChartDistComp.setTypes(t);

        Messreihe[] r = new Messreihe[6];
        Messreihe[] r2 = new Messreihe[6];
        Messreihe[] r3 = new Messreihe[6];

        Messreihe[] rS = new Messreihe[6];
        Messreihe[] rS2 = new Messreihe[6];
        Messreihe[] rS3 = new Messreihe[6];

        try {
            processDataA(grCN, grIWL, grAL, grBL, false, _ndc, runID);

        } catch (Exception ex) {
            Exceptions.printStackTrace(ex);
        }

        // JUST LINKED
        r[0] = zA.getHistogramNORM("[a] cc(CN,IWL)");
        r[1] = zB.getHistogramNORM("[b] cc(CN,AL)");
        r[2] = zC.getHistogramNORM("(c) cc(CN,BL)");

        // ALL PAIRS
        r2[0] = zD.getHistogramNORM("(d) cc(IWL,IWL)");
        r2[1] = zE.getHistogramNORM("(e) cc(AL,AL)");
        r2[2] = zF.getHistogramNORM("(f) cc(BL,BL)");

        // ALL PAIRS
        r3[0] = zG.getHistogramNORM("(g) cc(IWL,AL)");
        r3[1] = zH.getHistogramNORM("(h) cc(IWL,BL)");
        r3[2] = zI.getHistogramNORM("(h) cc(AL,BL)");


        Vector<Vector<Double>> d1 = new Vector<Vector<Double>>();
        d1.add(zA.dists);
        d1.add(zB.dists);
        d1.add(zC.dists);
        d1.add(zD.dists);
        d1.add(zE.dists);
        d1.add(zF.dists);
        d1.add(zG.dists);
        d1.add(zH.dists);
        d1.add(zI.dists);

//        KolmogorowSmirnowTester2.setNonShuffledData(d1);


        //        _showSuggestions(suggestA, "raw A I" );
        //        _showSuggestions(suggestB, "raw B I" );
        //        _showSuggestions(suggestC, "raw A B" );
        //
        //        _showSuggestions(suggestD, "raw A A" );
        //        _showSuggestions(suggestE, "raw B B" );
        //        _showSuggestions(suggestF, "raw I I" );
        //
        try {
            processDataA(grCN, grIWL, grAL, grBL, true, _ndc, runID);
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }

        // JUST LINKED
        r[3] = zA.getHistogramNORM("[a] cc(CN,IWL)");
        r[4] = zB.getHistogramNORM("[b] cc(CN,AL)");
        r[5] = zC.getHistogramNORM("(c) cc(CNL,BL)");

        // ALL PAIRS
        r2[3] = zD.getHistogramNORM("(d) cc(IWL,IWL)");
        r2[4] = zE.getHistogramNORM("(e) cc(AL,AL)");
        r2[5] = zF.getHistogramNORM("(f) cc(IWL,BL)");

        // ALL PAIRS
        r3[3] = zG.getHistogramNORM("(g) cc(IWL,AL)");
        r3[4] = zH.getHistogramNORM("(h) cc(IWL,BL)");
        r3[5] = zI.getHistogramNORM("(h) cc(AL,BL)");

        Vector<Vector<Double>> d2 = new Vector<Vector<Double>>();
        d2.add(zA.dists);
        d2.add(zB.dists);
        d2.add(zC.dists);
        d2.add(zD.dists);
        d2.add(zE.dists);
        d2.add(zF.dists);
        d2.add(zG.dists);
        d2.add(zH.dists);
        d2.add(zI.dists);

//        KolmogorowSmirnowTester2.setShuffledData(d2);

        MultiChartDistComp.setDefaultRange = true;
        MultiChartDistComp.xRangDEFAULT_MAX = 50.0;
        MultiChartDistComp.xRangDEFAULT_MIN = -50.0;
        MultiChartDistComp.yRangDEFAULT_MIN = 0.0;
        MultiChartDistComp.yRangDEFAULT_MAX = 1.0;

        MultiChartDistComp.setSymbols();

        // HIER MUSS ICH DANN ZHLEN ... 

//        MultiChartDistComp.open(r, runID+"[" + name + "] just linked page-pairs", "link strength", "nr of links", true);
//        MultiChartDistComp.open(r2, runID+"[" + name + "] all pairs (INTRA)", "link strength", "nr of links", true);
//        MultiChartDistComp.open(r3, runID+"[" + name + "] all pairs (INTER)", "link strength", "nr of links", true);

        String folder = "./data/out/";

        String kkType = KreuzKorrelation.getCalcTypeLabel();

        String tsr = getTSRange();

        String fn1 = tsr + name + "." + kkType + "." + "CC1." + runID;
        String fn2 = tsr + name + "." + kkType + "." + "CC2." + runID;
        String fn3 = tsr + name + "." + kkType + "." + "CC3." + runID;

        Container c1 = MultiChartDistComp.openAndStore(r, runID + "[" + name + "] just linked page-pairs", "link strength", "nr of links", true, folder, fn1, ".");
        Container c2 = MultiChartDistComp.openAndStore(r2, runID + "[" + name + "] all pairs (INTRA)", "link strength", "nr of links", true, folder, fn2, ".");
        Container c3 = MultiChartDistComp.openAndStore(r3, runID + "[" + name + "] all pairs (INTER)", "link strength", "nr of links", true, folder, fn3, ".");
        try {
            /**
             *
             * inr r, r2 und r3 sind nun die Histogramme fuer den SHAPIRO WILK
             * TEST.
             *
             */
            String tsvon = WikiHistoryExtraction2.getVon().getTime().toString();
            String tsbis = WikiHistoryExtraction2.getBis().getTime().toString();

            String time_range = "# von: " + von + "\n";
            time_range = time_range + "# bis: " + bis + "\n";

            time_range = time_range + "# TS von: " + tsvon + "\n";
            time_range = time_range + "# TS bis: " + tsbis + "\n";

            String run = tsr + name + "." + kkType + "." + "CC." + runID;

//            KolmogorowSmirnowTester2.test2(run, time_range, run);

        } catch (Exception ex) {
            Exceptions.printStackTrace(ex);
        }

        _ndc._flushNetworks(runID);
        if (exportViaGephi) {
            _ndc._flushGephiNetwork(runID, false, -100000.0);
        }
        /**
         * STORE SUCH LISTS in a external FILE ...
         */
        int uu = 0;
        for (ExtendedNodePairSFE p : linked) {
            uu++;
            System.out.println(uu + "+" + p.toString());
        }

        int ii = 0;
        for (ExtendedNodePairSFE p : notLinked) {
            ii++;
            System.out.println(ii + "-" + p.toString());

        }

        System.out.println("\n" + "*******");

        System.out.println("-" + ii);
        System.out.println("+" + uu);

        /**
         * RESET internal memory ....
         */
        Container[] cs = new Container[3];
        cs[0] = c1;
        cs[1] = c2;
        cs[2] = c3;

        return cs;
    }
    boolean useThreshold = false;

    private double initTS() {
        //String s = javax.swing.JOptionPane.showInputDialog(this, "Schwelle : " , ""+ts );
        String s = "0.3";

        double ts1 = Double.parseDouble(s);
        ts = ts1;
        return ts1;
    }
    
    public static StockDataLoader2 sdl;
//    static WikiDataCache rawRows;

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) throws FileNotFoundException, IOException, ParseException {


        HadoopTSAdapter.init();

//        sdl = StockDataLoader2.getLocalLoader("2009-01-01", "2009-12-31", "daxmap.dat");
//        sdl = StockDataLoader2.getLocalLoader("2009-01-01", "2009-12-31", "dowjonesmap.dat");

//        Thread t = new Thread(sdl);
//        t.start();

        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SimpleSFE.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SimpleSFE.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SimpleSFE.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SimpleSFE.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
//        java.awt.EventQueue.invokeLater(new Runnable() {
//            public void run() {
        mainModule = new SimpleSFE();
        mainModule.setVisible(true);
//            }
//        });
    }
    public static SimpleSFE mainModule = null;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem aboutMenuItem;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.ButtonGroup buttonGroup3;
    private javax.swing.JMenuItem contentsMenuItem;
    private javax.swing.JMenuItem copyMenuItem;
    private javax.swing.JMenuItem cutMenuItem;
    private javax.swing.JMenuItem deleteMenuItem;
    private javax.swing.JMenu editMenu;
    private javax.swing.JMenuItem exitMenuItem;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JMenu helpMenu;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton10;
    private javax.swing.JButton jButton11;
    private javax.swing.JButton jButton12;
    private javax.swing.JButton jButton13;
    private javax.swing.JButton jButton14;
    private javax.swing.JButton jButton15;
    private javax.swing.JButton jButton16;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton5;
    private javax.swing.JButton jButton6;
    private javax.swing.JButton jButton7;
    private javax.swing.JButton jButton8;
    private javax.swing.JButton jButton9;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JList jList1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel10;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JPanel jPanel9;
    private javax.swing.JRadioButton jRadioButton1;
    private javax.swing.JRadioButton jRadioButton2;
    private javax.swing.JRadioButton jRadioButton3;
    private javax.swing.JRadioButton jRadioButton4;
    private javax.swing.JRadioButton jRadioButton5;
    private javax.swing.JRadioButton jRadioButton6;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JTextField jTextField4;
    private javax.swing.JTextPane jTextPane1;
    private javax.swing.JButton jbAnalyseDATA;
    private javax.swing.JButton jbINSPECT;
    private javax.swing.JCheckBox jcbADJUST;
    private javax.swing.JCheckBox jcbCC;
    private javax.swing.JCheckBox jcbDT;
    private javax.swing.JCheckBox jcbES;
    private javax.swing.JCheckBox jcbLOadEditHistory;
    private javax.swing.JCheckBox jcbMW;
    private javax.swing.JCheckBox jcbONLYSELECTION;
    private javax.swing.JCheckBox jcbRATIO;
    private javax.swing.JCheckBox jcbRAW;
    private javax.swing.JCheckBox jcbWT;
    private javax.swing.JLabel jlZ;
    private javax.swing.JRadioButton jrbCCSelector;
    private javax.swing.JRadioButton jrbIW;
    private javax.swing.JRadioButton jrbSimpShuffle;
    private javax.swing.JTextField jtJAHR;
    private javax.swing.JTextField jtL;
    private javax.swing.JTextField jtLF;
    private javax.swing.JTextField jtMONAT;
    private javax.swing.JTextField jtTAG;
    private javax.swing.JTextField jtfEXTFILE;
    private javax.swing.JTextField jtfFolderEXTRACT;
    private javax.swing.JTextField jtfLIMIT;
    private javax.swing.JTextField jtfSTUDIE;
    private java.awt.Label label1;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JMenuItem openMenuItem;
    private javax.swing.JMenuItem pasteMenuItem;
    private javax.swing.JMenuItem saveAsMenuItem;
    private javax.swing.JMenuItem saveMenuItem;
    private javax.swing.JTextField selectedK;
    // End of variables declaration//GEN-END:variables
    String fn = null;

    public void getFileName() {
        fn = this.jtfEXTFILE.getText();
    }
    SequenceFile.Reader reader = null;
    Path path = null;
    FileSystem fs = null;
    Configuration config = null;
    boolean useHDFS = true;

    public void initFileSystem() throws IOException {
        
        config = new Configuration();

        System.out.println(">>HDFS<< :: " + fn);
        
        System.out.println("    public void initFileSystem() throws IOException { ... ");

        config.addResource(new Path("/etc/hadoop/conf/core-site.xml"));
        config.addResource(new Path("/etc/hadoop/conf/hdfs-site.xml"));

        fs = FileSystem.get(config);

        path = new Path(fn);
    }
    int z = 0;
    int binLevel = 0;
    int[] BINNING_RAW = {1, 24, 24 * 7};
    int[] BINNING_AV = {24, 7, 4};

    public void reset() {
        al = null;
        bl = null;
        iwl = null;
        cn = null;
        hash = new Hashtable<String, Vector<Messreihe>>();
    }

    public void _getMetaData(boolean multi) throws IOException {

        DefaultListModel dlm = new DefaultListModel();
        this.jList1.setModel(dlm);

        initBinLevel();

        path = new Path(fn);

        reader = new SequenceFile.Reader(fs, path, config);

        System.out.println("==> current binning  aw   : " + BINNING_AV[ binLevel]);
        System.out.println("==> current binning  raw  : " + BINNING_RAW[ binLevel]);
        System.out.println("--> process bucket        : " + fn);
        System.out.println("--> compression-codes     : " + reader.getCompressionCodec());
        System.out.println("--> key-classename        : " + reader.getKeyClassName());
        System.out.println("--> value-classname       : " + reader.getValueClassName());

        // is the listfile available ???
        File file = new File(jtLF.getText());
        System.out.println(">>> " + file.getAbsolutePath() + " --> " + file.exists());


        // Wieviele CN sind im merged listfile?
        int zz = 0;
        try {
            zz = initLastIndex(file);
        } catch (Exception ex) {
            zz = 1;
        }
        this.jlZ.setText("" + zz);

        // LISTFILE lesen ...
        localNet.loadListFile(file);

        if (multi) {

            System.out.println(">>> MULTI-mode ==> ON");

            z = Integer.parseInt(javax.swing.JOptionPane.showInputDialog(" Anzahl CN=", new Integer(zz)));
            for (int i = 0; i < z; i++) {

                al = new Vector<Messreihe>();
                bl = new Vector<Messreihe>();
                iwl = new Vector<Messreihe>();
                cn = new Vector<Messreihe>();

                hash.put((i + 1) + ".A.L", al);
                hash.put((i + 1) + ".B.L", bl);
                hash.put((i + 1) + ".CN", cn);
                hash.put((i + 1) + ".IWL", iwl);

            }
        } else {

            System.out.println(">>> MULTI-mode ==> OFF");

            al = new Vector<Messreihe>();
            bl = new Vector<Messreihe>();
            iwl = new Vector<Messreihe>();
            cn = new Vector<Messreihe>();

            hash.put("A.L", al);
            hash.put("B.L", bl);
            hash.put("CN", cn);
            hash.put("IWL", iwl);

        }
        System.out.println(">>> data can be loaded (2) ...");
    }

    public void getMetaDataOnly(boolean multi) throws IOException {

        DefaultListModel dlm = new DefaultListModel();
        this.jList1.setModel(dlm);

        if (this.jRadioButton3.isSelected()) {
            binLevel = 0;
        }
        if (this.jRadioButton1.isSelected()) {
            binLevel = 1;
        }
        if (this.jRadioButton2.isSelected()) {
            binLevel = 2;
        }

        path = new Path(fn);

        reader = new SequenceFile.Reader(fs, path, config);

        System.out.println("==> current binning  aw   : " + BINNING_AV[ binLevel]);
        System.out.println("==> current binning  raw  : " + BINNING_RAW[ binLevel]);
        System.out.println("--> process bucket        : " + fn);
        System.out.println("--> compression-codes     : " + reader.getCompressionCodec());
        System.out.println("--> key-classename        : " + reader.getKeyClassName());
        System.out.println("--> value-classname       : " + reader.getValueClassName());

        // is the listfile available ???
        File file = new File(jtLF.getText());
        System.out.println(">>> " + file.getAbsolutePath() + " --> " + file.exists());


        // Wieviele CN sind im merged listfile?
        int zz = 0;
        try {
            zz = initLastIndex(file);
        } catch (Exception ex) {
            zz = 1;
        }
        this.jlZ.setText("" + zz);

        // LISTFILE lesen ...
        localNet.debug = false;
        localNet.loadListFile(file);

        if (multi) {

            System.out.println(">>> MULTI-mode ==> ON");

            if (BucketLoaderTool.GUI_AUTOMODE) {
                z = zz;
            } else {
                z = Integer.parseInt(javax.swing.JOptionPane.showInputDialog(" Anzahl CN=", new Integer(zz)));
            }

            for (int i = 0; i < z; i++) {

                al = new Vector<Messreihe>();
                bl = new Vector<Messreihe>();
                iwl = new Vector<Messreihe>();
                cn = new Vector<Messreihe>();

                hash.put((i + 1) + ".A.L", al);
                hash.put((i + 1) + ".B.L", bl);
                hash.put((i + 1) + ".CN", cn);
                hash.put((i + 1) + ".IWL", iwl);

            }
        } else {

            System.out.println(">>> MULTI-mode ==> OFF");

            al = new Vector<Messreihe>();
            bl = new Vector<Messreihe>();
            iwl = new Vector<Messreihe>();
            cn = new Vector<Messreihe>();

            hash.put("A.L", al);
            hash.put("B.L", bl);
            hash.put("CN", cn);
            hash.put("IWL", iwl);

        }
        System.out.println(">>> data can be loaded now ...");
    }
    
    public Vector<Messreihe> al = null;
    public Vector<Messreihe> bl = null;
    public Vector<Messreihe> iwl = null;
    public Vector<Messreihe> cn = null;
    
    public Hashtable<String, Vector<Messreihe>> hash = new Hashtable<String, Vector<Messreihe>>();
    
    public LocalWikipediaNetwork2 localNet = new LocalWikipediaNetwork2();

    /**
     * Nun werden die Reihen geladen ...
     *
     * @param j
     * @param part
     * @throws IOException
     */
    private void listContent(int j, String part) throws IOException {

        fs = FileSystem.get(config);

        path = new Path(fn);
        reader = new SequenceFile.Reader(fs, path, config);

        Vector<String> groups = new Vector<String>();


        int LIMIT = j;
        boolean goOn = true;
        int i = 0;
        int error = 0;
        
        int A = 0;
        
        while (goOn && i <= LIMIT) {

            Text key = new Text();
            Text val = new Text();
A++;
System.out.println( A );

            goOn = reader.next(key);

            reader.getCurrentValue(val);

            Messreihe mr = new Messreihe();
            mr.setDescription(i + " ) " + fn + "_[" + key.toString() + "]");
            mr.setLabel(key.toString());
            mr.setIdentifier(key.toString());

            int J = Integer.parseInt(jtJAHR.getText());
            int M = Integer.parseInt(jtMONAT.getText());
            int T = Integer.parseInt(jtTAG.getText());

            int L = Integer.parseInt(jtL.getText());

            Calendar cal = new GregorianCalendar(J, M - 1, T, 0, 0);
//            Calendar cal = new GregorianCalendar(2007, 11, 1, 0, 0);
            int tsFRAME_days = L;
            int tsFRAME_hours = 24 * tsFRAME_days;


            try {
                Messreihe mr2 = expandTimeStampMap(val, cal, tsFRAME_hours, mr);

                if (BINNING_RAW[binLevel] != 1) {
                    mr2 = mr2.setBinningX_sum(BINNING_RAW[binLevel]);
                }

                if (jcbWT.isSelected()) {
                    mr2 = mr2.normalizeByPeriodeTrend(mr2, 24 * 7);
                } else if (jcbDT.isSelected()) {
                    mr2 = mr2.normalizeByPeriodeTrend(mr2, 24);
                }



                if (jCheckBox1.isSelected()) {
                    mr2.calcLog10_for_Y();
                }

                String group = lookupGroupLabel(key);

                if (groups.contains(group)) {
                } else {
                    groups.add(group);
                }

                if (group != null) {
                    // System.out.println("g=" + group);
                    Vector<Messreihe> vmr = hash.get(group);
                    if (vmr != null) {
                        vmr.add(mr2);
                    }

                    i = i + 1;
                }
            } catch (Exception ex) {
                Logger.getLogger(TSBucket.class.getName()).log(Level.SEVERE, null, ex);
                error = error + 1;
            }

            int code = 1;

        }
        System.out.println("--> nr of records     : " + (i - 1));
        System.out.println("--> groups            : " + groups.toString());


        javax.swing.JOptionPane.showMessageDialog(this, "Data was loaded from SEQ-file ... ");
        System.out.println(hash.keySet());

    }
    /**
     * Nun werden die Reihen geladen ...
     *
     * @param j
     * @param part
     * @throws IOException
     */
    int selection = -1;
    String lastLoglabel = "?";

    private String loadRowsForSelectionOnly(int index) throws IOException {

        if (index == selection) {
            System.out.println(">>> DO NOT LOAD (" + selection + " : " + index + ") again ... ");
            return lastLoglabel;
        }

        selection = index;

        String loadLogLabel = getTSRange() + "_" + (index + 1);

        String indexS = (index + 1) + ".";

        fs = FileSystem.get(config);

        path = new Path(fn);
        reader = new SequenceFile.Reader(fs, path, config);

        Vector<String> groups = new Vector<String>();

        int J = Integer.parseInt(jtJAHR.getText());
        int M = Integer.parseInt(jtMONAT.getText());
        int T = Integer.parseInt(jtTAG.getText());

        int L = Integer.parseInt(jtL.getText());

        Calendar cal = new GregorianCalendar(J, M - 1, T, 0, 0);
        //            Calendar cal = new GregorianCalendar(2007, 11, 1, 0, 0);
        int tsFRAME_days = L;
        int tsFRAME_hours = 24 * tsFRAME_days;

        System.out.println("START: " + cal.getTime().toString());

        //loadLogLabel = loadLogLabel.concat( "_" + cal.getTime().toString() );


        int LIMIT = Integer.MAX_VALUE;


        loadLogLabel = loadLogLabel.concat("_" + LIMIT);


        boolean goOn = true;
        int i = 0;
        int error = 0;
        while (goOn && i <= LIMIT) {

            Text key = new Text();
            Text val = new Text();

            goOn = reader.next(key);

            String group = lookupGroupLabel(key);

            System.out.println( i + " ) " + fn + " " + group );

            if (group != null) {

                if (group.startsWith(indexS)) {

                    reader.getCurrentValue(val);



                    Messreihe mr = new Messreihe();
                    mr.setDescription(i + " ) " + fn + "_[" + key.toString() + "]");
                    mr.setLabel(key.toString());
                    mr.setIdentifier(key.toString());

                    System.out.println( i + " ) " + fn + "_[" + key.toString() + "]" );


                    try {

                        Messreihe mr2 = expandTimeStampMap(val, cal, tsFRAME_hours, mr);



                        if (BINNING_RAW[binLevel] != 1) {
                            mr2 = mr2.setBinningX_sum(BINNING_RAW[binLevel]);
                        }

                        if (jcbWT.isSelected()) {
                            if (i == 0) {
                                System.out.println(">>> remove weekly trends ... ");
                            }
                            mr2 = mr2.normalizeByPeriodeTrend(mr2, 24 * 7);
                            if (i == 0) {
                                loadLogLabel = loadLogLabel.concat("_rwt");
                            }

                        } else if (jcbDT.isSelected()) {
                            if (i == 0) {
                                System.out.println(">>> remove dayly trends ... ");
                            }
                            mr2 = mr2.normalizeByPeriodeTrend(mr2, 24);
                            if (i == 0) {
                                loadLogLabel = loadLogLabel.concat("_rdt");
                            }
                        } else {
                            if (i == 0) {
                                System.out.println("--- remove no trends --- ");
                            }
                            if (i == 0) {
                                loadLogLabel = loadLogLabel.concat("_ooo");
                            }
                        }



                        if (jCheckBox1.isSelected()) {
                            mr2.calcLog10_for_Y();
                            if (i == 0) {
                                loadLogLabel = loadLogLabel.concat("_log10");
                            }
                        } else {
                            if (i == 0) {
                                loadLogLabel = loadLogLabel.concat("_ooooo");
                            }
                        }





                        if (groups.contains(group)) {
                        } else {
                            groups.add(group);
                        }

                        // System.out.println("g=" + group);
                        Vector<Messreihe> vmr = hash.get(group);
                        if (vmr != null) {
                            vmr.add(mr2);
                        }

                        i = i + 1;

                    } catch (Exception ex) {
                        Logger.getLogger(TSBucket.class.getName()).log(Level.SEVERE, null, ex);
                        error = error + 1;
                    }

                    int code = 1;

                }
            }


        }
        // warum -1 hier?? UNKLAR, daher entfernt
        int z = i;

        System.out.println("--> nr of records     : " + (i - 1));
        System.out.println("--> groups            : " + groups.toString());

        _showBucketContentStat2(z, groups);

//        showStockData(  );

        System.out.println("==> LLL               : " + loadLogLabel);
        lastLoglabel = loadLogLabel;
        return loadLogLabel;

    }
    boolean initialized = false;

    private Messreihe expandTimeStampMap(Text val, Calendar calVON, int tsFRAME_hours, Messreihe mr) {
        String hash = val.toString().substring(1, val.toString().length() - 2);

        long t0 = calVON.getTimeInMillis();

        Calendar calBIS = (Calendar) calVON.clone();
        calBIS.add(Calendar.HOUR, tsFRAME_hours);

        if (!initialized) {
            System.out.println(calVON.getTime());
            System.out.println(calBIS.getTime());
            initialized = true;
        }

        double[] data = new double[tsFRAME_hours];
        for (int i = 0; i < tsFRAME_hours; i++) {
            data[i] = 0.0;
        }

        String[] pairs = hash.split(", ");
        for (String p : pairs) {
            String[] kv = p.split("=");
            Long k = Long.parseLong(kv[0]);
            Integer v = Integer.parseInt(kv[1]);
            Date d = new Date(k * 1000);
            if (d.after(calVON.getTime()) && d.before(calBIS.getTime())) {
                // System.out.println( d );
                long dt = (k * 1000) - t0;
                int i = (int) (dt / (1000 * 60 * 60));
                data[i] = v;
                // System.out.println( );
            };
        }

        for (int i = 0; i < tsFRAME_hours; i++) {
            mr.addValue(data[i]);
        }
        return mr;
    }

    private String lookupGroupLabel(Text key) {
        //System.out.println( "KEY="  + key );
        return localNet.getGroup(key);
    }

//    private void sumUpData() {
//    }
//
//    private void sumUpData(int i) {
//    }
    private void showCharts1() {
        MultiChart.open(al, "A.L", "t", "#access", false, getMrVectorInfo(al), null);
        MultiChart.open(bl, "B.L", "t", "#access", false, getMrVectorInfo(bl), null);
        MultiChart.open(iwl, "IWL", "t", "#access", false, getMrVectorInfo(iwl), null);
        MultiChart.open(cn, "CN", "t", "#access", false, getMrVectorInfo(cn), null);
    }

    private JComponent[] showChartsRAW(int i, boolean multi) {

        JComponent[] c = new JComponent[4];
        c[0] = new JPanel();
        c[1] = new JPanel();
        c[2] = new JPanel();
        c[3] = new JPanel();


        Vector<Messreihe> al = null;
        Vector<Messreihe> bl = null;
        Vector<Messreihe> iwl = null;
        Vector<Messreihe> cn = null;

        
        
        if (multi) {
            al = hash.get(i + "." + "A.L");
            bl = hash.get(i + "." + "B.L");
            iwl = hash.get(i + "." + "IWL");
            cn = hash.get(i + "." + "CN");
        } else {
            al = hash.get("A.L");
            bl = hash.get("B.L");
            iwl = hash.get("IWL");
            cn = hash.get("CN");
        }
        

        if (al != null) {
            MultiChart mc = MultiChart.open2(al, i + " LN", "t", getYLabel("#access"), false, getMrVectorInfo(al));
//////
//            MesswertTabelle tab = new MesswertTabelle();
//            File f = new File("data/out/FS_" + getTSRange() + "_" + i + "_LN.dat");
//            tab.setMessReihen(al);
//            tab.writeToFile(f);
//
            c[0] = (JComponent) mc.getCP();
        }
        if (bl != null) {
            MultiChart mc = MultiChart.open2(bl, i + " GN", "t", getYLabel("#access"), false, getMrVectorInfo(bl));
//
//            MesswertTabelle tab = new MesswertTabelle();
//            File f = new File("data/out/FS_" + getTSRange() + "_" + i + "_GN.dat");
//            tab.setMessReihen(bl);
//            tab.writeToFile(f);
//
            c[1] = (JComponent) mc.getCP();
        }
        if (iwl != null) {
            MultiChart mc = MultiChart.open2(iwl, i + " IWL", "t", getYLabel("#access"), false, getMrVectorInfo(iwl));
//
//            MesswertTabelle tab = new MesswertTabelle();
//            File f = new File("data/out/FS_" + getTSRange() + "_" + i + "_IWL.dat");
//            tab.setMessReihen(iwl);
//            tab.writeToFile(f);
//
            c[2] = (JComponent) mc.getCP();
        }
        if (cn != null) {
            MultiChart mc = MultiChart.open2(cn, i + " CN", "t", getYLabel("#access"), false, getMrVectorInfo(cn));
//
//            MesswertTabelle tab = new MesswertTabelle();
//            File f = new File("data/out/FS_" + getTSRange() + "_" + i + "_CN.dat");
//            tab.setMessReihen(cn);
//            tab.writeToFile(f);
//
            c[3] = (JComponent) mc.getCP();
        }
        return c;
    }

    private void showChartsAV() {

        System.out.println(">>> SHOW >>> ChartsAV() ...");
        Vector<Messreihe> v = new Vector<Messreihe>();
        v.addAll(av(al, null, BINNING_AV[binLevel]));
        v.addAll(av(bl, null, BINNING_AV[binLevel]));
        v.addAll(av(iwl, null, BINNING_AV[binLevel]));
        v.addAll(av(cn, null, BINNING_AV[binLevel]));

        gtsb.putAll(v);

        // String CN_Name = hash.get("CN").elementAt(0).label;
        MultiChart.open(v, "", "t", "<#access>", true, "", null);
    }

    private JComponent[] _showChartsAV(int i, boolean multi) {

        Vector<Messreihe> al = null;
        Vector<Messreihe> bl = null;
        Vector<Messreihe> iwl = null;
        Vector<Messreihe> cn = null;

        String CN_Name = null;

        if (multi) {
            al = hash.get(i + "." + "A.L");
            bl = hash.get(i + "." + "B.L");
            iwl = hash.get(i + "." + "IWL");
            cn = hash.get(i + "." + "CN");

        } else {
            al = hash.get("A.L");
            bl = hash.get("B.L");
            iwl = hash.get("IWL");
            cn = hash.get("CN");
        }

        CN_Name = null;
        try {
            if (cn != null) {
                if (cn.size() > 0) {
                    CN_Name = cn.elementAt(0).label;
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            javax.swing.JOptionPane.showMessageDialog(this, "no time series data for CN!");
        }

        int B2 = 24;

        Vector<Messreihe> v = new Vector<Messreihe>();
        if (al != null) {
            Vector<Messreihe> vmr = av(al, null, BINNING_AV[binLevel]);
            vmr.elementAt(0).setLabel("A.L");
            v.addAll(vmr);
        }
        if (bl != null) {
            Vector<Messreihe> vmr = av(bl, null, BINNING_AV[binLevel]);
            vmr.elementAt(0).setLabel("B.L");
            v.addAll(vmr);
        }
        if (iwl != null) {
            Vector<Messreihe> vmr = av(iwl, null, BINNING_AV[binLevel]);
            vmr.elementAt(0).setLabel("IWL");
            v.addAll(vmr);
        }
        if (cn != null) {
            Vector<Messreihe> vmr = av(cn, null, BINNING_AV[binLevel]);
            vmr.elementAt(0).setLabel("CN");
            v.addAll(vmr);
        }

        JComponent[] c = new JComponent[1];

        MultiChart mc = MultiChart.open2(v, CN_Name + " AV", "t", "< " + getYLabel("access rate") + ">", true, "");

//        if( store ) {
//            MesswertTabelle tab = new MesswertTabelle();
//            File f = new File("data/out/FS_" + getTSRange() + CN_Name + "_AVERAGES.dat");
//            tab.setMessReihen(v);
//            tab.writeToFile(f);
//        }    

        c[0] = (JComponent) mc.getCP();
        return c;
    }

    private JComponent[] calcTRI(int i, boolean multi) {

        Vector<Messreihe> al = null;
        Vector<Messreihe> bl = null;
        Vector<Messreihe> iwl = null;
        Vector<Messreihe> cn = null;

        String CN_Name = null;

        if (multi) {
            al = hash.get(i + "." + "A.L");
            bl = hash.get(i + "." + "B.L");
            iwl = hash.get(i + "." + "IWL");
            cn = hash.get(i + "." + "CN");

        } else {
            al = hash.get("A.L");
            bl = hash.get("B.L");
            iwl = hash.get("IWL");
            cn = hash.get("CN");
        }

        CN_Name = null;
        try {
            if (cn != null) {
                if (cn.size() > 0) {
                    CN_Name = cn.elementAt(0).label;
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            javax.swing.JOptionPane.showMessageDialog(this, "no time series data for CN!");
        }

        double nLN = al.size();

        double nGN = bl.size();

        double nIWL = iwl.size();

        double nCN = cn.size();

        System.out.println("nLN=" + nLN + " nGN=" + nGN + " nIWL=" + nIWL + " nCN=" + nCN);

        Messreihe aCN = sum2(cn);
        Messreihe aLN = sum2(al);
        Messreihe aGN = sum2(bl);
        Messreihe aIWL = sum2(iwl);

        Vector<Messreihe> v = new Vector<Messreihe>();
//        v.add( aCN );
//        v.add( aLN );
//        v.add( aGN );
//        v.add( aIWL);

        Messreihe TA = aCN.divide_by(aLN);
        Messreihe TB = aIWL.divide_by(aGN);


        Messreihe mLRELt = TA.scaleY_2(nLN);
        Messreihe mGRELt = TB.scaleY_2(nGN / nIWL);

        mGRELt.setLabel("G.REL");
        mLRELt.setLabel("L.REL");

        Messreihe RI = mLRELt.divide_by(mGRELt);
//        
//                            DecimalFormat form = new DecimalFormat("0.0000000");

        JComponent[] c = new JComponent[1];
//        
//        mLRELt.normalize();
//        mGRELt.normalize();

        v.add(mLRELt.setBinningX_average(7 * 4));
        v.add(mGRELt.setBinningX_average(7 * 4));
        v.add(RI.setBinningX_average(7 * 4));


        MultiChart mc = MultiChart.open2(v, CN_Name + " TRI", "t", "L.REL & G.REL " + getYLabel("access rate"), true, "");

//        if( store ) {
//            MesswertTabelle tab = new MesswertTabelle();
//            File f = new File("data/out/FS_" + getTSRange() + CN_Name + "_AVERAGES.dat");
//            tab.setMessReihen(v);
//            tab.writeToFile(f);
//        }    

        c[0] = (JComponent) mc.getCP();
        return c;
    }

    private Vector<Messreihe> __calcTRI_rows(int i, boolean multi, int scale) {

        i = i + 1;

        Vector<Messreihe> v = new Vector<Messreihe>();

        Vector<Messreihe> al = null;
        Vector<Messreihe> bl = null;
        Vector<Messreihe> iwl = null;
        Vector<Messreihe> cn = null;

        String CN_Name = null;

        if (multi) {
            al = hash.get(i + "." + "A.L");
            bl = hash.get(i + "." + "B.L");
            iwl = hash.get(i + "." + "IWL");
            cn = hash.get(i + "." + "CN");

        } else {
            al = hash.get("A.L");
            bl = hash.get("B.L");
            iwl = hash.get("IWL");
            cn = hash.get("CN");
        }

        CN_Name = null;
        try {
            if (cn != null) {
                if (cn.size() > 0) {
                    CN_Name = cn.elementAt(0).label;
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            javax.swing.JOptionPane.showMessageDialog(this, "no time series data for CN!");
        }

        try {

            Messreihe aCN = null;
            Messreihe aLN = null;
            Messreihe aGN = null;
            Messreihe aIWL = null;

            double nCN = 0.0;
            if (cn != null) {
                nCN = cn.size();
                aCN = sum2(cn);
            }

            double nLN = 0.0;
            if (al != null) {
                nLN = al.size();
                aLN = sum2(al);
            }

            double nGN = 0.0;
            if (bl != null) {
                nGN = bl.size();
                aGN = sum2(bl);
            }

            double nIWL = 0.0;
            if (iwl != null) {
                nIWL = iwl.size();
                aIWL = sum2(iwl);
            }

            System.out.println("nLN=" + nLN + " nGN=" + nGN + " nIWL=" + nIWL + " nCN=" + nCN);

            Messreihe TA = new Messreihe("TA." + i);
            Messreihe TB = new Messreihe("TB." + i);
            Messreihe RI = new Messreihe("RI." + i);

            boolean calcR = true;

            if (aLN != null && aCN != null) {
                TA = aCN.divide_by(aLN);

            } else {
                calcR = false;
            }

            if (aIWL != null && aGN != null) {
                TB = aIWL.divide_by(aGN);
            } else {
                calcR = false;

            }

            Messreihe mLRELt = TA.scaleY_2(nLN);
            Messreihe mGRELt = TB.scaleY_2(nGN / nIWL);

            mGRELt.setLabel("G.REL");
            mLRELt.setLabel("L.REL");

            if (calcR) {
                RI = mLRELt.divide_by(mGRELt);
            }

            v.add(mLRELt.setBinningX_average(scale));
            v.add(mGRELt.setBinningX_average(scale));
            v.add(RI.setBinningX_average(scale));


        } catch (Exception ex) {
            v.add(new Messreihe(i + ".L"));
            v.add(new Messreihe(i + ".G"));
            v.add(new Messreihe(i + ".R"));
        }
        return v;
    }

//    private void __showChartsSUM() {
////        MultiChart.open(sum(al), "A.L", "t", "log( #access )", false, getMrVectorInfo(al));
////        MultiChart.open(sum(bl), "B.L", "t", "log( #access)", false, getMrVectorInfo(bl));
////        MultiChart.open(sum(iwl), "IWL", "t", "log( #access)", false, getMrVectorInfo(iwl));
////        MultiChart.open(sum(cn), "CN", "t", "log( #access)", false, getMrVectorInfo(cn));
//    }
    private String getMrVectorInfo(Vector<Messreihe> al) {
        StringBuffer sb = new StringBuffer();
        sb.append(al.size() + " rows" + "\n\n");
        for (Messreihe mr : al) {
            sb.append(mr.summeY() + " : " + mr.getLabel() + "\n");
        }
        return sb.toString();
    }

    private Messreihe av2NoBinning(Vector<Messreihe> al, String label) {
        int i = 0;
        Messreihe mr = new Messreihe();
        if (al != null) {

            for (Messreihe m : al) {
                mr = mr.add(m);
                i++;
            }
            mr.divide_Y_by((double) i);
            mr.setLabel(label);

            // mr = mr.setBinningX_sum(BINNING_AV[binLevel]);
        }
        return mr;
    }

    private Messreihe av2(Vector<Messreihe> al, String label) {
        int i = 0;
        Messreihe mr = new Messreihe();
        if (al != null) {

            for (Messreihe m : al) {
                mr = mr.add(m);
                i++;
            }
            mr.divide_Y_by((double) i);
            mr.setLabel(label);

            mr = mr.setBinningX_sum(BINNING_AV[binLevel]);
        }
        return mr;
    }

    private Vector<Messreihe> av(Vector<Messreihe> al, String label, int b2) {
        Vector<Messreihe> d = new Vector<Messreihe>();
        int i = 0;
        Messreihe mr = new Messreihe();
        for (Messreihe m : al) {
            mr = mr.add(m);
            i++;
        }
        mr.divide_Y_by((double) i);
        if (label != null) {
            mr.setLabel(label);
        }
        if (b2 != 1) {
            mr = mr.setBinningX_sum(b2);
        }
        d.add(mr);
        return d;
    }

    private double summe(Vector<Messreihe> cn) {
        Messreihe mr = new Messreihe();
        for (Messreihe m : cn) {
            mr = mr.add(m);
            // System.out.println(" \t\t" + m.label );
        }
        double d = mr.sumYValues();
        return d;
    }

    private Messreihe sum2(Vector<Messreihe> cn) {
        Messreihe mr = new Messreihe();
        int c = 1;
        for (Messreihe m : cn) {
            mr = mr.add2(m, false);
//            System.out.println( c + ". ");
//            c++;
        }
        return mr;
    }

    private Vector<Messreihe> _sum(Vector<Messreihe> cn) {
        Vector<Messreihe> d = new Vector<Messreihe>();
        Messreihe mr = new Messreihe();
        for (Messreihe m : cn) {
            mr = mr.add(m);
        }
        d.add(mr);
        return d;
    }

//    private Vector<Messreihe> binning(Vector<Messreihe> v, int i, String l) {
//        Vector<Messreihe> b = new Vector<Messreihe>();
//        for (Messreihe m : v) {
//            m = m.setBinningX_sum(i);
//            m.setLabel(l);
//            b.add(m);
//        }
//        return b;
//    }
//    private Messreihe binning2(Vector<Messreihe> vv, int i, String l) {
//        Messreihe v = vv.elementAt(0).setBinningX_sum(i);
//        v.setLabel(l);
//        return v;
//    }
    private JComponent[] showChartsRatio(int i, boolean multi) {
        JComponent[] c = new JComponent[1];

        if (multi) {
            Vector<Messreihe> al = hash.get(i + "." + "A.L");
            Vector<Messreihe> bl = hash.get(i + "." + "B.L");
            Vector<Messreihe> iwl = hash.get(i + "." + "IWL");
            Vector<Messreihe> cn = hash.get(i + "." + "CN");

            Vector<Messreihe> v = new Vector<Messreihe>();

            Messreihe a2 = av2(al, i + ".A.L");
            Messreihe a1 = av2(cn, i + ".CN");

            Messreihe b2 = av2(bl, i + ".B.L");
            Messreihe b1 = av2(iwl, i + ".IWL");

            Messreihe r1LOCAL = a1.divide_by(a2);
            Messreihe r2GLOBAL = b1.divide_by(b2);

            v.add(r1LOCAL);
            v.add(r2GLOBAL);

            gtsb.rows.put("RLocal", r1LOCAL);
            gtsb.rows.put("RGlobal", r2GLOBAL);

            c = new JComponent[1];
            c[0] = new JPanel();

            Vector<Messreihe> vv = (Vector<Messreihe>) hash.get(i + ".CN");
            String CN_Name = "CN?";
            if (vv != null) {
                if (vv.size() > 0) {
                    CN_Name = vv.elementAt(0).label;
                    MultiChart mc = MultiChart.open2(v, CN_Name, "t", "RATIO", true, "");

                    // CLEAN PATHNAME
                    CN_Name = CN_Name.replace("/", "_");

                    MesswertTabelle tab = new MesswertTabelle();
                    File f = new File("data/out/FS_" + getTSRange() + CN_Name + "_RATIO.dat");
                    tab.setMessReihen(v);
                    tab.writeToFile(f);

                    c[0] = (JComponent) mc.getCP();

                }
            }
        } else {

            Vector<Messreihe> al = hash.get("A.L");
            Vector<Messreihe> bl = hash.get("B.L");
            Vector<Messreihe> iwl = hash.get("IWL");
            Vector<Messreihe> cn = hash.get("CN");

            Vector<Messreihe> v = new Vector<Messreihe>();

            Messreihe a2 = av2(al, "A.L");
            Messreihe a1 = av2(cn, "CN");

            Messreihe b2 = av2(bl, "B.L");
            Messreihe b1 = av2(iwl, "IWL");

            Messreihe r1LOCAL = a1.divide_by(a2);
            Messreihe r2GLOBAL = b1.divide_by(b2);

            v.add(r1LOCAL);
            v.add(r2GLOBAL);

            gtsb.rows.put("RLocal", r1LOCAL);
            gtsb.rows.put("RGlobal", r2GLOBAL);

            gtsb.rows.put("A.L", a2);
            gtsb.rows.put("CN", a1);

            gtsb.rows.put("B.L", b2);
            gtsb.rows.put("IWL", b1);

            c = new JComponent[1];
            c[0] = new JPanel();



            Vector<Messreihe> vv = (Vector<Messreihe>) hash.get(".CN");
            String CN_Name = "CN?";
            if (vv != null) {
                if (vv.size() > 0) {
                    CN_Name = vv.elementAt(0).label;

                    MultiChart mc = MultiChart.open2(v, CN_Name, "t", "RATIO", true, "");

                    MesswertTabelle tab = new MesswertTabelle();
                    File f = new File("data/out/FS_" + getTSRange() + "_" + CN_Name + "_RATIO.dat");
                    tab.setMessReihen(v);
                    tab.writeToFile(f);

                    c[0] = (JComponent) mc.cp;
                }
            }


        }
        String CN_Name = "?"; //hash.get("CN").elementAt(0).label;
        return c;
    }

    private Vector<Messreihe> calcChartsRatio(int i, boolean multi) {
        Vector<Messreihe> back = new Vector<Messreihe>();
        if (multi) {
            Vector<Messreihe> al = hash.get(i + "." + "A.L");
            Vector<Messreihe> bl = hash.get(i + "." + "B.L");
            Vector<Messreihe> iwl = hash.get(i + "." + "IWL");
            Vector<Messreihe> cn = hash.get(i + "." + "CN");

            Vector<Messreihe> v = new Vector<Messreihe>();

            Messreihe a2 = av2NoBinning(al, i + ".A.L");
            Messreihe a1 = av2NoBinning(cn, i + ".CN");

            Messreihe b2 = av2NoBinning(bl, i + ".B.L");
            Messreihe b1 = av2NoBinning(iwl, i + ".IWL");

            Messreihe r1LOCAL = a1.divide_by(a2);
            Messreihe r2GLOBAL = b1.divide_by(b2);



            gtsb.rows.put("RLocal", r1LOCAL);
            gtsb.rows.put("RGlobal", r2GLOBAL);

            Vector<Messreihe> vv = (Vector<Messreihe>) hash.get(i + ".CN");
            String CN_Name = "CN?";
            if (vv != null) {
                if (vv.size() > 0) {
                    CN_Name = vv.elementAt(0).label;

                    r1LOCAL.comments.add(CN_Name);
                    r1LOCAL.setLabel(r1LOCAL.getLabel() + ":" + CN_Name);
                    r2GLOBAL.comments.add(CN_Name);
                    r2GLOBAL.setLabel(r2GLOBAL.getLabel() + ":" + CN_Name);

                    v.add(r1LOCAL);
                    v.add(r2GLOBAL);

                    back.add(r1LOCAL);
                    back.add(r2GLOBAL);

                    MultiChart mc = MultiChart.open2(v, CN_Name, "t", "RATIO", true, "");
                    mc.setVisible(true);

                    MesswertTabelle tab = new MesswertTabelle();
                    File f = new File("data/out/FS_" + getTSRange() + CN_Name + "_RATIO.dat");
                    tab.setMessReihen(v);
                    tab.writeToFile(f);


                }
            }

        } else {

            Vector<Messreihe> al = hash.get("A.L");
            Vector<Messreihe> bl = hash.get("B.L");
            Vector<Messreihe> iwl = hash.get("IWL");
            Vector<Messreihe> cn = hash.get("CN");

            Vector<Messreihe> v = new Vector<Messreihe>();

            Messreihe a2 = av2NoBinning(al, "A.L");
            Messreihe a1 = av2NoBinning(cn, "CN");

            Messreihe b2 = av2NoBinning(bl, "B.L");
            Messreihe b1 = av2NoBinning(iwl, "IWL");

            Messreihe r1LOCAL = a1.divide_by(a2);
            Messreihe r2GLOBAL = b1.divide_by(b2);



            v.add(r1LOCAL);
            v.add(r2GLOBAL);

            back.add(r1LOCAL);
            back.add(r2GLOBAL);

            gtsb.rows.put("RLocal", r1LOCAL);
            gtsb.rows.put("RGlobal", r2GLOBAL);

            gtsb.rows.put("A.L", a2);
            gtsb.rows.put("CN", a1);

            gtsb.rows.put("B.L", b2);
            gtsb.rows.put("IWL", b1);

            Vector<Messreihe> vv = (Vector<Messreihe>) hash.get(i + ".CN");
            String CN_Name = "CN?";
            if (vv != null) {
                if (vv.size() > 0) {
                    CN_Name = vv.elementAt(0).label;
                    MultiChart mc = MultiChart.open2(v, CN_Name, "t", "RATIO", true, "");
                    mc.setVisible(true);

                    r1LOCAL.comments.add(CN_Name);
                    r1LOCAL.setLabel(r1LOCAL.getLabel() + ":" + CN_Name);
                    r2GLOBAL.comments.add(CN_Name);
                    r2GLOBAL.setLabel(r2GLOBAL.getLabel() + ":" + CN_Name);



                    MesswertTabelle tab = new MesswertTabelle();
                    File f = new File("data/out/FS_" + getTSRange() + "_" + CN_Name + "_RATIO.dat");
                    tab.setMessReihen(v);
                    tab.writeToFile(f);

                }
            }

        }
        String CN_Name = "?"; //hash.get("CN").elementAt(0).label;
        return back;
    }

    private void showChartsRatio() {
        Vector<Messreihe> v = new Vector<Messreihe>();

        Messreihe a2 = av2(al, "A.L");
        Messreihe a1 = av2(cn, "CN");

        Messreihe b2 = av2(bl, "B.L");
        Messreihe b1 = av2(iwl, "IWL");

        Messreihe r1LOCAL = a1.divide_by(a2);
        Messreihe r2GLOBAL = b1.divide_by(b2);

        v.add(r1LOCAL);
        v.add(r2GLOBAL);

        gtsb.rows.put("RLocal", r1LOCAL);
        gtsb.rows.put("RGlobal", r2GLOBAL);

        gtsb.rows.put("A.L", a2);
        gtsb.rows.put("CN", a1);

        gtsb.rows.put("B.L", b2);
        gtsb.rows.put("IWL", b1);


        String CN_Name = hash.get("CN").elementAt(0).label;
        MultiChart.open(v, CN_Name, "t", "<#access>", true, "", null);

        MesswertTabelle tab = new MesswertTabelle();
        File f = new File("data/out/FS_" + CN_Name + "_RATIO.dat");
        tab.setMessReihen(v);
        tab.writeToFile(f);
    }
    /**
     *
     * @param file
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    boolean debug = false;

    private int initLastIndex(File file) throws FileNotFoundException, IOException {
        int max = 0;
        BufferedReader br = new BufferedReader(new FileReader(file));
        while (br.ready()) {
            String line = br.readLine();
            if (line != null) {
                if (debug) {
                    System.out.println(line);
                }
                String[] fields = line.split("\t");
//                System.out.println(fields[0]);

                int ix = fields[0].indexOf(".");

                String f2 = fields[0].substring(0, ix);

                int i = Integer.parseInt(f2);
//                System.out.println(i);
                if (i > max) {
                    max = i;
                }
            }
        }
        zCN = max;
        return max;
    }
    int zCN = 0;

    private void extractREP_access(boolean multi, int i) {

        String fileRelMapData = "iwl_corpus_RELMAP_TEMP.dat.corpus.JS.data";
        StringBuffer sbRelMapData = new StringBuffer();

        Vector<Messreihe> al = null;
        Vector<Messreihe> bl = null;
        Vector<Messreihe> iwl = null;
        Vector<Messreihe> cn = null;

        String CN_Name = null;

        if (multi) {
            al = hash.get(i + "." + "A.L");
            bl = hash.get(i + "." + "B.L");
            iwl = hash.get(i + "." + "IWL");
            cn = hash.get(i + "." + "CN");

        } else {
            al = hash.get("A.L");
            bl = hash.get("B.L");
            iwl = hash.get("IWL");
            cn = hash.get("CN");
        }

        sbRelMapData.append("var dataC = google.visualization.arrayToDataTable([ ['Country', 'REL click']");
        sbRelMapData.append(getRelMapLinesACCESS(cn));
        sbRelMapData.append(getRelMapLinesACCESS(iwl));
        sbRelMapData.append("]);\n\n");

        FileWriter fw2;
        try {
            fw2 = new FileWriter(new File(fileRelMapData));
            fw2.write(sbRelMapData.toString());
            fw2.flush();
            fw2.close();
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }



    }

    private void openFrame4Index(final int i, final boolean multi, final String lll) {

        Runnable r = new Runnable() {
            public void run() {

                System.out.println("### the frame will come soon ...");

                JComponent[][] charts = new JComponent[2][3];

                charts[0][0] = (JComponent) new JPanel();
                charts[1][0] = (JComponent) new JPanel();

                charts[0][1] = (JComponent) new JPanel();
                charts[1][1] = (JComponent) new JPanel();

                charts[0][2] = (JComponent) new JPanel();
                charts[1][2] = (JComponent) new JPanel();

                System.out.println("### av ...");
                if (jcbMW.isSelected()) {
                    JComponent[] c = _showChartsAV(i + 1, multi);
                    charts[0][2] = c[0];
                }

                System.out.println("### raw ...");
                if (jcbRAW.isSelected()) {
                    JComponent[] c = showChartsRAW(i + 1, multi);
                    charts[0][0] = c[0];
                    charts[1][0] = c[1];
                    charts[0][1] = c[3];
                    charts[1][1] = c[2];
                }

                System.out.println("### ratio ...");
                if (jcbRATIO.isSelected()) {
                    JComponent[] c = showChartsRatio(i + 1, multi);
                    charts[1][2] = c[0];
                }

                JComponent[] c = calcTRI(i + 1, multi);
                charts[1][2] = c[0];



                _TEMPlll = lll;
                cf = ChartFrame.open(charts, "?", lll);
                cf.setSize(Toolkit.getDefaultToolkit().getScreenSize());
                cf.repaint();




            }
        };


        Thread t = new Thread(r);
        t.start();


    }

//    private Vector<Messreihe> log(Vector<Messreihe> al) {
//        for (Messreihe mr : al) {
//            mr.calcLog10_for_Y();
//        }
//        return al;
//    }
    private void openFrame4Index2(final int i, final boolean multi, final String lll, FileWriter fw) {

        boolean multi2 = multi;


//        Runnable r = new Runnable() {
//            public void run() {

        JComponent[][] charts = new JComponent[2][4];

        System.out.println("### the frame will come soon ...");

        System.out.println("\n*** " + lll + " > create a panel ...\n");

        charts[0][0] = (JComponent) new JPanel();
        charts[1][0] = (JComponent) new JPanel();

        charts[0][1] = (JComponent) new JPanel();
        charts[1][1] = (JComponent) new JPanel();

        charts[0][2] = (JComponent) new JPanel();
        charts[1][2] = (JComponent) new JPanel();

        charts[0][3] = (JComponent) new JPanel();
        charts[1][3] = (JComponent) new JPanel();




















        System.out.println("# av ...");
        if (jcbMW.isSelected()) {

            JComponent[] c = _showChartsAV(i + 1, multi);
            charts[0][2] = c[0];

        }

        System.out.println("# raw ...");
        if (jcbRAW.isSelected()) {
            JComponent[] c = showChartsRAW(i + 1, multi);
//            charts[0][0] = c[0];
//            charts[1][0] = c[1];
            charts[0][1] = c[3];
            charts[1][1] = c[2];
        }

        System.out.println("# ratio ...");
        if (jcbRATIO.isSelected()) {
            JComponent[] c = _showChartsAV(i + 1, multi);
            charts[0][3] = c[0];

        }

        JComponent[] c = showChartsRatio(i + 1, multi);
        charts[1][2] = c[0];

        _TEMPlll = lll;
//        cf = ChartFrame.open(charts, "?", lll);
//        cf.setSize(Toolkit.getDefaultToolkit().getScreenSize());
//        cf.repaint();
//
//
//        cf._store(_TEMPlll);
//
//        cf.setVisible(false);
//            }
//        }
//
//
//        Thread t = new Thread(r);
//        t.start();


    }
    String _TEMPlll;
    ChartFrame cf = null;
    Hashtable<String, String> nameHash = new Hashtable<String, String>();
    Vector<String> nameList = new Vector<String>();
    Vector<String> nameListFULL = new Vector<String>();

    public void initListe2() {
        DefaultListModel dlm = (DefaultListModel) this.jList1.getModel();
        for (int i = 0; i < zCN; i++) {
            String key = (i + 1) + "." + "CN";

            String kO = key;

            Vector<Messreihe> cn = hash.get(key);
            String data = "?";
            if (cn != null) {
                key = key + "(size=" + cn.size() + ")";
//                    
//                if (cn.size() > 0) {
//                    if ( cn.elementAt(0) != null) {
//                        data = "" + cn.elementAt(0).yValues.size();
//                        Messreihe r = cn.elementAt(0);
//                        if (r != null) {
//                            key = key + " : " + r.label;
//                        }
//                    }
//                    System.out.println(key + " " + (cn != null) + " " + data );
//                }
//                else { 
                String NAME = localNet.coded_pages.get(kO).firstElement();
                //System.out.println( "llokup in net " + kO + " => " + NAME );
                data = "<" + NAME + ">";
                nameHash.put(i + "", NAME);
                nameList.add(NAME.substring(5));
                nameListFULL.add(NAME);
//                }                

            }

            dlm.addElement(key + data);
        }
        jList1.setModel(dlm);
        System.out.println("DONE. List is ready ...");
        this.repaint();
    }

    private void initListe() {
        DefaultListModel dlm = (DefaultListModel) this.jList1.getModel();
        for (int i = 0; i < zCN; i++) {
            String key = (i + 1) + "." + "CN";

            String kO = key;

            Vector<Messreihe> cn = hash.get(key);
            String data = "?";
            if (cn != null) {
                key = key + "(size=" + cn.size() + ")";

                if (cn.size() > 0) {
                    if (cn.elementAt(0) != null) {
                        data = "" + cn.elementAt(0).yValues.size();
                        Messreihe r = cn.elementAt(0);
                        if (r != null) {
                            key = key + " : " + r.label;
                        }
                    }
                    System.out.println(key + " " + (cn != null) + " " + data);
                } else {
                    String NAME = localNet.coded_pages.get(kO).firstElement();
                    //System.out.println( "llokup in net " + kO + " => " + NAME );
                    data = "{{{ " + NAME + " }}}";
                }

            }
            dlm.addElement(key + data);
        }
        System.out.println("DONE");
    }
    GTSB2 gtsb = null;

    private void initGlobalTSBuffer() {
        System.out.println(">>> GTSB ist neu initialisiert ...");
        gtsb = new GTSB2();
    }

    public void _loadRowsWithLimit() throws IOException, NumberFormatException {
        String in = jtfLIMIT.getText();

        int l = Integer.parseInt(in);
        System.out.println("\n");
        if (l < 0) {
            System.out.println(">>>>> NO LIMITS");
            listContent(Integer.MAX_VALUE, "part-r-00001");

        } else {
            System.out.println(">>>>> LIMITS = " + l);
            listContent(l, "part-r-00001");
        }

//            initListe();
//            for (int i = 0; i < z; i++) {
//
//                openFrame4Index(i, true);
//
//            }
    }

    private void loadRowsForSelectionOnly() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void showBucketContentStat(int z, Vector<String> groups) {

        int s = 0;
        System.out.print("==> TOTAL: " + z + " {");
        for (String g : groups) {
            int rz = 0;
            Vector<Messreihe> r = hash.get(g);
            if (r != null) {
                rz = r.size();
                s = s + rz;     // so viele nodes sind in der GRUPPE
            }
            System.out.print("g:" + g + "(" + rz + ");");
        }

        System.out.println("} \n==> DELTA = " + (z - s));

    }

    private void _showBucketContentStat2(int z, Vector<String> groups) {

        int s = 0;
        System.out.print("==> TOTAL: " + z + " {");
        for (String g : groups) {
            System.out.print(getGroupDetails(g));
        };
        System.out.println("} \n==> DELTA = " + (z - s));

    }

    private String getGroupDetails(String g) {
        int s = 0;
        int rz = 0;
        int rSOLL = 0;

        Vector<Messreihe> r = hash.get(g);
        Vector<String> labels = localNet.getNamesForGroup(g);

        if (labels != null) {
            rSOLL = labels.size();
        }

        if (r != null) {
            rz = r.size();
            s = s + rz;     // so viele nodes sind in der GRUPPE
        }
        return "g:" + g + "(" + rz + "," + rSOLL + ");";
    }

    private String getGroupDetails2(String g) {
        int s = 0;
        int rz = 0;
        int rSOLL = 0;

        Vector<Messreihe> r = hash.get(g);
        Vector<String> labels = localNet.getNamesForGroup(g);

        if (labels != null) {
            rSOLL = labels.size();
        }

        if (r != null) {
            rz = r.size();
            s = s + rz;     // so viele nodes sind in der GRUPPE
        }
        return g + "\t" + rz + "\t" + rSOLL;
    }

    /**
     *
     * @param g
     * @return
     */
    private String getGroupDetails3(String gr) {

        Vector<SingleRowTSO> ops = HadoopTSAdapter.rowOperators;

        int s = 0;
        int rz = 0;
        int rSOLL = 0;

        Vector<Messreihe> r = hash.get(gr);
        Vector<String> labels = localNet.getNamesForGroup(gr);

        if (labels != null) {
            rSOLL = labels.size();
        }

        if (r != null) {
            rz = r.size();
            s = s + rz;     // so viele nodes sind in der GRUPPE
        }

        String rl = "gr=" + gr + "\trz=" + rz + "\t+rSOLL=" + rSOLL;

        for (SingleRowTSO op : ops) {
            for (Messreihe rr : r) {
                try {
                    rl = rl.concat(op.processReihe(rr));
                } catch (Exception ex) {
                    Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
                }

            }
        }

        return "{" + rl + "}";

    }

    private void _calcEditActivity() {

        HashSet hs = localNet.codes;
        ArrayList al = new ArrayList();
        for (Object o : hs) {
            al.add(o);
        }
        Collections.sort(al);

        final String hl = "key" + "\t" + "#MR" + "\t" + "SUM(access)" + "\t" + "MW( access )\n";
        System.out.println("[HEADER] " + hl);

        for (Object k : al) {

            String key = (String) k;


            Vector<Messreihe> V = this.hash.get(key);
            int zCN = getEditActivity(V);
            //System.out.println("### " + key + " :: " + zCN);


        }

    }

    private int getEditActivity(Vector<Messreihe> grCN) {
        int z = 0;
        for (Messreihe m : grCN) {


            Messreihe m2 = loadEventDataFromCache(m);

            if ( m2 != null ) z = z + (int) m2.summeY();
        }
        return z;
    }

    private Messreihe loadEventDataFromCache(Messreihe m) {

        String wna = m.getIdentifier();

        if (wna == null) {
            noIdentifier++;

            System.out.println(">>> no identifier " + m.getLabel() + "(SimpleSFE.java line: 4238 ... )  loadEventDataFromCache(Messreihe m) ");

            // return new Messreihe();

            wna = m.getLabel().substring(0, m.getLabel().length() - 7);

        }

        // System.out.println( ">>> load edits now ... (" + wna + ")" );


        TSCache.RAM = false;
        TSCache.WebHBase = true;

        TSCache.debug = false;

        Messreihe esA = null;
        try {

            esA = WikiHistoryExtraction2.loadPageHistory(new WikiNode(wna));

        } catch (IOException ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            Logger.getLogger(SimpleSFE.class.getName()).log(Level.SEVERE, null, ex);
        }

        return esA;
    }

    private String getTSRange() {
        String r = this.jtJAHR.getText() + "_" + this.jtMONAT.getText() + "_" + this.jtTAG.getText() + "_" + this.jtL.getText() + "_";
        return r;
    }

    private Messreihe _processDataA2(Vector<Messreihe> grCN, Messreihe fW, Vector<Messreihe> grIWL, Vector<Messreihe> grAL, Vector<Messreihe> grBL,
            boolean shuffle, NetDensityCalc ndc, Vector<Messreihe> norms) {

        suggestA = new Vector<ExtendedNodePairSFE>();
        suggestB = new Vector<ExtendedNodePairSFE>();
        suggestC = new Vector<ExtendedNodePairSFE>();

        suggestD = new Vector<ExtendedNodePairSFE>();
        suggestE = new Vector<ExtendedNodePairSFE>();
        suggestF = new Vector<ExtendedNodePairSFE>();

        StringBuffer data = new StringBuffer("***** shuffle=" + shuffle + " *****\n");
        data.append("*****      ts=" + ts + " *****\n");

        // cc - analyse


//        NEUE RECHENMETHODE HIER EINBAUEN ...



//        zA = CCProzessor.getAll(fW, grIWL, shuffle, ndc, "zA", ts, norms);
//        zB = CCProzessor.getAll(fW, grAL, shuffle, ndc, "zB", ts, norms);
//        zC = CCProzessor.getAll(fW, grBL, shuffle, ndc, "zC", ts, norms);

        Messreihe kkI = CCProzessor.getPairComparison(fW, grCN, shuffle, ndc, fn, ts, norms);

        data.append("zA.size : " + zA.dists.size() + "\t" + zA.getValueAboveTS(ts) + "\n");
        data.append("zB.size : " + zB.dists.size() + "\t" + zB.getValueAboveTS(ts) + "\n");
        data.append("zC.size : " + zC.dists.size() + "\t" + zC.getValueAboveTS(ts) + "\n");

//        zD = CCProzessor.getPartial(grIWL, grIWL, shuffle, ts, suggestA, ndc, "zD");
//        zE = CCProzessor.getPartial(grAL, grAL, shuffle, ts, suggestB, ndc, "zE");
//        zF = CCProzessor.getPartial(grBL, grBL, shuffle, ts, suggestC, ndc, "zF");
//        data.append("zD.size : " + zD.dists.size() + "\t" + zD.getOver(ts) + "\n");
//        data.append("zE.size : " + zE.dists.size() + "\t" + zE.getOver(ts) + "\n");
//        data.append("zF.size : " + zF.dists.size() + "\t" + zF.getOver(ts) + "\n");
//
//        zG = CCProzessor.getPartial(grIWL, grAL, shuffle, ts, suggestD, ndc, "zG");
//        zH = CCProzessor.getPartial(grIWL, grBL, shuffle, ts, suggestE, ndc, "zH");
//        zI = CCProzessor.getPartial(grAL, grBL, shuffle, ts, suggestF, ndc, "zI");
//        data.append("zG.size : " + zG.dists.size() + "\t" + zG.getOver(ts) + "\n");
//        data.append("zH.size : " + zH.dists.size() + "\t" + zH.getOver(ts) + "\n");
//        data.append("zI.size : " + zI.dists.size() + "\t" + zI.getOver(ts) + "\n");

        data.append("\n");
        try {
            ndc.logToAnalysisFile(data.toString(), "CC.INFOFLOW.FD." + shuffle);
        } catch (Exception ex) {
            Logger.getLogger(AdvancedSequenceFileExplorer.class.getName()).log(Level.SEVERE, null, ex);
        }




        return kkI;


    }
    String modeA = "raw TS";
    String modeB = "semantic norm";
    String modeC = "semantic local";
    String modeD = "semantic global";
    String computeMode = "raw TS";

    private Vector<Messreihe> _getNormierung(int i) {

        Vector<Messreihe> norms = new Vector<Messreihe>();

        Messreihe cn = this.hash.get(i + ".CN").elementAt(0);

        Messreihe one = new Messreihe("1");
        for (int j = 0; j < cn.getSize()[0]; j++) {
            one.addValuePair((double) i, 1.0);
        }

        Vector<Messreihe> cn2 = new Vector<Messreihe>();
        // SUMME IWL und CN
        // a) normalisiert mit Umgebung

        Vector<Messreihe> grCN = this.hash.get(i + ".CN");
        Vector<Messreihe> grIWL = this.hash.get(i + ".IWL");
        Vector<Messreihe> grAL = this.hash.get(i + ".A.L");
        Vector<Messreihe> grBL = this.hash.get(i + ".B.L");

        System.out.println(grCN.size());
        System.out.println(grIWL.size());
        System.out.println(grAL.size());
        System.out.println(grBL.size());

        Messreihe sum1 = Messreihe.calcSumOfRows(grIWL, grCN, "sumCore");

        // MITTELWERT der UMGEBUNBG
        Messreihe av2 = Messreihe.calcAVOfRows(grAL, grBL, "avEnv");

        if (computeMode.equals(modeA)) {
            CCProzessor.NORM = 0;
            System.err.println("*** A)" + modeA + " ***");
        } else if (computeMode.equals(modeB)) {
            CCProzessor.NORM = 1;
            System.err.println("*** B)" + modeB + " ***");
        } else {
            CCProzessor.NORM = 0;
        }


        norms.add(one);
        norms.add(av2);

        return norms;




    }

    private int selectCN() {
        if (this.jList1.getSelectedIndices().length < 1) {
            javax.swing.JOptionPane.showMessageDialog(this, "no node selected !");
            return -1;
        } else {
            return this.jList1.getSelectedIndex();
        }
    }

    private int getTau() {
        return Integer.parseInt(selectedK.getText());
    }

    private String getYLabel(String a) {
        if (jCheckBox1.isSelected()) {
            return "log(" + a + ") ";
        } else {
            return a;
        }
    }

    private Object getRelMapLinesACCESS(Vector<Messreihe> cn) {

        StringBuffer sb = new StringBuffer();

        for (Messreihe m : cn) {

            double sum = m.summeY();
            String[] s = m.getLabel().split("___");

            //['pt',1.053 ],
            sb.append(",['" + s[0] + "'," + sum + "]\n");

        }

        return sb.toString();

    }

    private String getTimeString() {
        initBinLevel();
        return getTSRange() + "_" + getYLabel("access_" + BINNING_RAW[ binLevel]);
    }

    private void initBinLevel() {
        if (this.jRadioButton3.isSelected()) {
            binLevel = 0;
        }
        if (this.jRadioButton1.isSelected()) {
            binLevel = 1;
        }
        if (this.jRadioButton2.isSelected()) {
            binLevel = 2;
        }
    }

    private double getLengthInDays() {
        return Double.valueOf(jtL.getText());
    }

    private double getSum(Vector<Messreihe> cn) {
        double s = 0;
        for (Messreihe mr : cn) {
            s = s + mr.sumYValues();
        }
        return s;
    }

    private void _runCN_Analysis(boolean multi) throws Exception {


        String ext = javax.swing.JOptionPane.showInputDialog("Extension:");

        File f = new File("/home/kamir/ANALYSIS/TRI/TRI_" + jtfSTUDIE.getText() + "_" + ext + ".csv");

        OriginProject op = new OriginProject();
        op.initFolder("/home/kamir/ANALYSIS/TRI/" + jtfSTUDIE.getText());


        FileWriter fw = null;
        try {
            fw = new FileWriter(f);
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }

        int max = jList1.getModel().getSize();

        try {
            fw.write("#    ext = " + ext + "\n");
            fw.write("# studie = " + jtfSTUDIE.getText() + "\n");

        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }

        Vector<Messreihe> G = new Vector<Messreihe>();
        Vector<Messreihe> L = new Vector<Messreihe>();
        Vector<Messreihe> R = new Vector<Messreihe>();



        for (int k = 0; k < max; k++) {

            int i = k;
            System.out.println(">>> i=" + i);

            Vector<Messreihe> temp = __calcTRI_rows(k, true, 7);

            String cnName = getCN_Name(k, multi);


            Messreihe a = temp.elementAt(0);
            a.setLabel(" L." + cnName);
//            a.calcLog10_for_Y();   
//            a.normalize();
            L.add(a);

            Messreihe b = temp.elementAt(1);
            b.setLabel(" G." + cnName);
//            b.calcLog10_for_Y();
//            b.normalize();
            G.add(b);

            Messreihe c = temp.elementAt(2);
            c.setLabel(" R." + cnName);
//            c.calcLog10_for_Y();
//            c.normalize();
            R.add(c);


//
//            Vector<Messreihe> al = null;
//            Vector<Messreihe> bl = null;
//            Vector<Messreihe> iwl = null;
//            Vector<Messreihe> cn = null;
//
//            String CN_Name = null;
//
//
//            al = hash.get(i + "." + "A.L");
//            bl = hash.get(i + "." + "B.L");
//            iwl = hash.get(i + "." + "IWL");
//            cn = hash.get(i + "." + "CN");
//
//            if (al != null && bl != null && cn != null && iwl != null) {
//
//
//                double LRELt = 0.0;
//                Double GRELt = 0.0;
//
//                double R = 0.0;
//
//                CN_Name = null;
//                try {
//                    if (cn != null) {
//                        if (cn.size() > 0) {
//                            CN_Name = cn.elementAt(0).label;
//                            double nLN = al.size();
//
//                            double nGN = bl.size();
//
//                            double nIWL = iwl.size();
//
//                            double aCN = getSum(cn);
//                            double aLN = getSum(al);
//                            double aGN = getSum(bl);
//                            double aIWL = getSum(iwl);
//
//                            LRELt = nLN * (aCN / aLN) * 1000000.0;
//                            GRELt = (nGN / nIWL) * (aIWL / aGN) * 1000000.0;
//
//                            if (GRELt.isNaN() || GRELt.isInfinite() || GRELt.doubleValue() == 0.0) {
//                                R = 0.0;
//                                GRELt = 0.0;
//                            } else {
//                                R = LRELt / GRELt;
//                            }
//
//                            DecimalFormat form = new DecimalFormat("0.0000000");
//
//
//                            String line = CN_Name + "\t" + form.format(LRELt) + "\t" + form.format(GRELt) + "\t" + form.format(R) + "\n";
//
//      
//                            
//                            System.out.println( line );
//                            
//                            try {
//                                fw.write(line);
//                            } catch (IOException ex) {
//                                Exceptions.printStackTrace(ex);
//                            }
//                        }
//                    }
//                } catch (Exception ex) {
//                    ex.printStackTrace();
//                    javax.swing.JOptionPane.showMessageDialog(this, "no time series data for CN!");
//                } finally {
//
//                    try {
//                        fw.write(i + "\t" + 0 + "\t" + 0 + "\t" + 0 + "\n");
//                    } catch (IOException ex) {
//                        Exceptions.printStackTrace(ex);
//                    }
//                }
//
//            } else {
//
//                String E = "E";
//                try {
//                    fw.write(i + "\t" + E + "\t" + E + "\t" + E + "\n");
//                } catch (IOException ex) {
//                    Exceptions.printStackTrace(ex);
//                }
//            }


        }

        MultiChartDistComp.setDefaultRange = true;
        MultiChartDistComp.xRangDEFAULT_MAX = 60.0;
        MultiChartDistComp.xRangDEFAULT_MIN = 0.0;
        MultiChartDistComp.yRangDEFAULT_MIN = 1000.0;
        MultiChartDistComp.yRangDEFAULT_MAX = -10.0;

        MultiChart.open(L, true, jtfSTUDIE.getText() + " # L");
        MultiChart.open(G, true, jtfSTUDIE.getText() + " # G");
        MultiChart.open(R, true, jtfSTUDIE.getText() + " # R");

        op.addMessreihen(L, "L_", true);
        op.addMessreihen(G, "G_", true);
        op.addMessreihen(R, "R_", true);

        try {
            fw.close();
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }
    }

    private String getCN_Name(int k, boolean multi) {

        String CN_Name = null;

        int i = k + 1;

        if (multi) {
            al = hash.get(i + "." + "A.L");
            bl = hash.get(i + "." + "B.L");
            iwl = hash.get(i + "." + "IWL");
            cn = hash.get(i + "." + "CN");

        } else {
            al = hash.get("A.L");
            bl = hash.get("B.L");
            iwl = hash.get("IWL");
            cn = hash.get("CN");
        }

        CN_Name = null;
        try {
            if (cn != null) {
                if (cn.size() > 0) {
                    CN_Name = cn.elementAt(0).label;
                } else {
                    CN_Name = i + ".CN";
                }
            } else {
                CN_Name = i + ".CN";
            }
        } catch (Exception ex) {

            CN_Name = i + ".CN";
        }
        return CN_Name;
    }
}
